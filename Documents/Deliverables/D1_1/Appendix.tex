\begin{appendices}

The following appendices represent some alternative approaches that can be taken to realise the closest vector and sentence similarity methods using quantum-enabled systems. They are listed here as stretch-goals or workarounds to consider following the implementation of the methods discussed in the bulk of this document.

\section{Alternative approach to DisCo}\label{app:loco_algo}

%\noindent\rule{\textwidth}{1pt}
While the DisCo formalism is central to our body of work, we may consider alternative methods for data relationship encodings; instead of defining word meanings from their proximity to nearby words, we use can opt for a look-up model. This removes the distributional aspect of DisCo, but still enables use of the compositional approach via tensoring the meanings. As such, we propose calling this the ``LoCo'' (\textbf{Lo}ok-up \textbf{Co}mpositional) model. We make use of a basis set of terms, wherein the words follow an ``orthogonal''-like set of meanings, with each word having little to no associated meaning with another in the language. For this, we may consider the approach of Ogden~\cite{OgdenC.K.CharlesKay1940BE:a}. The author defines approximately 850 words which may be used to construct all other words in a language. We can treat these as the basis set of words, and define a mapping of our corpus to the basis by examining a synonym-based look-up (e.g. using NTLK~\cite{BirdKleinLoper09}, or spaCy~\cite{spacy2}). 
\begin{itemize}
    \item For each word in Ogden's data set, tag and type each word.
    \item Give each type a set of unique bit-patterns to represent meaning in this space.
    \item Examine, tokenise and tag corpus data.
    \item Check basis set for appearance of word: if word exists, return given basis bit-pattern; if not, recursively examine synonyms and related words for matching terms in basis.
    \item The returned bit-patterns for the matched words enable the creation of an equal superposition to represent the corpus word meaning-space.
    \item If no matching term found, create new unique bit-pattern.
\end{itemize}
%\noindent\rule{\textwidth}{1pt}
The use of this approach would be easily implementable in the pre-processing stage as described within Section~\ref{sec:design_considerations}. We describe the method here as a comparison may be beneficial for real-world data at a later stage in the project.

\section{Hamming distance and Durr-Hoyer optimization}\label{app:hamming_dh}
The DH algorithm defines a method to determine a minimum value in a quantum state, wherein a threshold value is used to define relative from the calculated Hamming distance values. This method makes use of individual pieces proposed by Trugenberger~\cite{Trugenberger_2001,Trugenberger_2002} and Wiebe et al.~\cite{Wiebe_Kapoor_Svore_2014}, and is modified as follows:

\begin{itemize}
\item Begin by flipping all possible Hamming distance qubit values, turning the smallest into the largest values.
\item Define a threshold value for the DH algorithm randomly in the range of min to max of what the register may represent (the middle of the range is acceptable).
\item Using quantum register arithmetic, subtract the flipped Hamming value from the threshold. Should the value underflow, the outermost qubit will be flipped from $\vert0\rangle\rightarrow \vert 1\rangle$.
\item Applying a Pauli-$Z$ gate on the outermost qubit will perform a shift of the register from $\vert 1\rangle\rightarrow -\vert 1\rangle$.
\item Using the diffusion operator from Grover's search algorithm, all marked states increase in amplitude relative to unmarked states.
\item A new threshold can be set and iterated upon to the required convergence condition has been reached.
\item A measurement of the state will now return the closest matching state with high probability, Multiple shot-based measurements will allow a statistical collection of the hierarchical state probability matches.
\end{itemize}
Given the implementation of methods as discussed in Section~\ref{par:qram_alt_approach}, this would be a viable extension to the model, and may potentially offer an advantage in terms of implementability.

\section{Controlled $R_y$ rotation for measurement-based state determination}\label{app:ry_phase}
In addition to the use of a Hamming distance approach, as proposed in Section~\ref{sub:hamming_dist}, we may use the Hamming distance to control the angle of rotation from $|0\rangle\rightarrow\vert 1\rangle$ for an additional ancillary qubit, $\vert a \rangle$. Assuming we have use of a controlled rotation gate around the $y$-axis of the Bloch sphere, hence labelled $\textsc{CR}_y(\theta,c,t)$, where $\theta$ is the angle of rotation, $c$ is the control qubit, and $t$ is the target, we may operate as follows:
\begin{itemize}
    \item Encode the Hamming distance as described earlier, into a register $\vert H\rangle = \vert 0\rangle\otimes\dots\vert i-1\rangle$ of size $i$ qubits.
    \item Apply Pauli-$x$ to all qubits in $\vert H \rangle$ to flip the resulting Hamming distance.
    \item Iterate over each qubit in $\vert H\rangle$, applying $\textsc{CR}_y(\pi/i, \vert i \rangle, \vert a\rangle)$.
    \item Perform projective measurement on the the ancillary qubit with $\vert 1\rangle\langle 1 \vert$.
\end{itemize}
Following these steps the system, after a measurement, will most likely be that with the lowest Hamming distance, and hence be the closest to the given test data. By repeating this with multiple shots, a statistical distribution can be obtained over the closest matching states.
While this approach has the downside of multiple shots being required to obtain the result, it offers an experimentally realizable approach, assuming a low-overhead up-front state creation.

\end{appendices}


