\section{Implementation of DisCo Algorithms: closest vector problem}
\label{sec:implementation_of_closest_Vector_algorithms}
Many of the specific details of the implementation of the DisCo algorithms were detailed in Deliverable 1.1. This section elaborates on these details, including the encoding of binary patterns into a superposition of states, an alternative method for encoding the Hamming distance into a state's amplitude from that which was outlined in Deliverable 1.1, and finally the way in which measurement should be conducted at the end of an experimental `shot'.

\subsection{Encoding of Binary States into Superposition}
\label{sec:encoding_binary_states_superposition}
Method 1 of Deliverable 1.1 Section 3.2 gave an overview of a method which we observed to successfully encode binary vectors into a superposition of states with equal amplitudes. This method was initially proposed by Trugenberger \cite{Trugenberger_2001} and is detailed below.

For notational simplicity, we define the following mappings:
\begin{align}
    \textrm{NOT}_{a} &: \vert a \rangle & \rightarrow & & \vert& \lnot a \rangle, \\  
    \textrm{XOR}_{a,b} &: \vert a \rangle \vert b \rangle & \rightarrow & & \vert& a \rangle \vert a \oplus b \rangle, \\  
    \textrm{nXOR}_{a_{1},\dots a_{n} ,b} &: \vert a_1 \rangle \dots\vert a_{n} \rangle \vert b \rangle &\rightarrow & & \vert& a_1 \rangle \dots \vert a_{n} \rangle \vert b \oplus (a_{1} \wedge \dots \wedge a_{n}) \rangle  .
\end{align}

The goal of the algorithm is to encode a set of binary vector into a superposition of states. For a set of $N$ binary patterns $p^i = \{p_1^i, \dots, p_n^i \} $ of length $n$ for $i=1,\dots,N$, we require three registers of qubits; a memory register $\vert m \rangle$ of length $n$, a temporary register $\vert p \rangle$ of length $n$, and an ancilla register $\vert u \rangle$ of length $2$ initialised as $\vert 01 \rangle$. $\vert m \rangle$ and $\vert p \rangle$ are initialised to the state of all $0$'s. Thus the initial state is

\begin{align}
    \vert \psi_0 \rangle &= \vert p \rangle \vert u \rangle \vert m \rangle \\
     &= \vert 0_1 \dots  0_n \rangle \vert 0 1 \rangle \vert 0_1\dots  0_n \rangle .
\end{align}

Each of the binary vectors is encoded into the superposition sequentially. For each iteration of the encoding algorithm, a new state is generated in the superposition (excluding the final iteration). The new state generated is termed as the `active' state of the next iteration. All other states are said to be `inactive'. Note, in each iteration of the algorithm, the `active' state will always begin with $\vert u \rangle = \vert 01\rangle$. 

During a single iteration, a binary vector is stored in integer format, which is then serially encoded bit-wise into the temporary register $\vert p \rangle$ resulting in the state $\vert \psi_1 \rangle$;
\begin{align}
    \vert \psi_1 \rangle & =  \vert p_1^1\dots p_n^1\rangle\vert 01\rangle\vert0_1\dots0_n \rangle.
\end{align}

This binary representation is then copied into the memory register $\vert m \rangle$ of the `active' state by applying a $2\textrm{XOR}$ gate on $\vert \psi_1 \rangle$;

\begin{align}
\label{eq:encode_psi2}
    \vert \psi_2 \rangle & =  \prod\limits_{j=1}^{n} \textrm{2XOR}_{p_j^i u_2 m_j} \vert \psi_1 \rangle.
\end{align}

Next, the \textrm{XOR} gate followed by a \textrm{NOT} gate are applied to all qubits in $\vert m \rangle$ using the corresponding qubits in $\vert p \rangle$ as control. This sets the qubits in $\vert m\rangle$ to $1$ if the respective qubit index in both $\vert m \rangle$ and $\vert p \rangle$ match, else to $0$. Thus, the state whose register $\vert m \rangle$ matches the pattern stored in $\vert p \rangle$ will be set to all $1$'s while the other states will have at least one occurrence of $0$ in $\vert m \rangle$.

\begin{align}
\label{eq:encode_psi3}
  \vert \psi_3 \rangle & =  \prod\limits_{j=1}^{n} \textrm{NOT}_{m_j} \textrm{XOR}_{p_j^i m_j}  \vert \psi_2 \rangle  .
\end{align}

Now that the state being encoded has been selected, an \textrm{nXOR} operation is applied to the first qubit in the ancilla register using the qubits in $\vert m \rangle$ as the $n$ control qubits;

\begin{align}
\label{eq:encode_psi4}
	\vert \psi_4 \rangle & =  \textrm{nXOR}_{m_1\dots m_n u_1}  \vert \psi_3 \rangle.
\end{align}

\noindent The target qubit whose initial value is $0$ will be set to $1$ if $\vert m \rangle$ consists of only $1$'s. This is the case when the pattern in $\vert m \rangle$ is identical to the pattern being encoded (ie. the pattern stored in $\vert p \rangle$).

In order to generate a new state in the superposition, it is required to effectively `carve-off' some of the amplitude of an existing state so the new state has a non-zero amplitude. To do this, we apply the unitary matrix $S^i$ to the second ancilla qubit $u_2$ using the first ancilla qubit $u_1$ as a control;

\begin{align}
\vert \psi_5 \rangle  =  \textrm{CS}_{u_1 u_2}^{p+1-i}  \vert \psi_4 \rangle,
\end{align}
\noindent where
\begin{align}
S^i = 
\begin{bmatrix}
\sqrt{\frac{i-1}{i}} & \frac{1}{\sqrt{i}} \\
-\frac{1}{\sqrt{i}}  & \sqrt{\frac{i-1}{i}}
\end{bmatrix}.
\end{align}

\noindent The newly generated state will be entangled with $\vert u\rangle = \vert 11 \rangle$ while the previous `active' state that was used to `carve-off' this new state with $\vert u\rangle = \vert 10 \rangle$. All other states will be entangled with $\vert u\rangle = \vert 00 \rangle$. 

In order to apply the next iteration of the algorithm, the previous steps used to select the active state have to be `un-computed'. This is done by applying the operations in equations \eqref{eq:encode_psi2} - \eqref{eq:encode_psi4} in reverse order

\begin{align}
	\vert \psi_6 \rangle & =  \textrm{nXOR}_{m_1\dots m_n u_1}  \vert \psi_5 \rangle    ,                               \\
	\vert \psi_7 \rangle & =  \prod\limits_{j=n}^{1} \textrm{XOR}_{p_j^i m_j} \textrm{NOT}_{m_j}  \vert \psi_6 \rangle, \\
	\vert \psi_8 \rangle & =  \prod\limits_{j=n}^{1} 2\textrm{XOR}_{p_j^i u_2 m_j} \vert \psi_7 \rangle.
\end{align}

\noindent This results in the previous `active' state being entangled with $\vert u \rangle = \vert 00 \rangle$ while the new state with $\vert u \rangle = \vert 01 \rangle$, which identifies it as the new `active' state. The previous `active' state's register $\vert m \rangle$ now contains the pattern $\{ p_1^i, \dots, p_n^i \}$ while the new `active' state's register $\vert m \rangle$ is set to all zeroes. 

Finally, the register $\vert p \rangle$ for every state must be set to all zeroes by sequentially applying \textrm{NOT} gates to each qubit in $\vert p \rangle$ according to the pattern that was just encoded. The superposition is now ready for the next iteration to encode another pattern. 

Note, this algorithm assumes that the number of patterns to be encoded is known beforehand. This is required to generate the unitary $S^i$ matrices and apply them in the correct order. This algorithm works even for multiple identical input patterns. The total number of qubits used in this algorithm is $2n+2$, of which $n+2$ are reusable after the implementation since the qubits in $\vert p \rangle$ and $\vert u \rangle$ are all reset to $\vert 0\rangle$ upon completion.

Appendix~\ref{app:circuits} features representative circuits generated for intermediate states $\vert \psi_{0}\rangle \rightarrow \vert \psi_{7}\rangle$ encoding a pattern of $0b00100$.

\subsection{Closest Vector Problem}
\label{sec:closest_vector_problem}
The purpose of this closest vector implementation is to encode the relative distance between each state's binary pattern and a single test pattern $x = \{x_1,\dots, x_n\}$ into the amplitude of each corresponding state.

Sections~\ref{sec:hamming_distance_trugenberger_method} and \ref{sec:hamming_distance_cry_rotation} outline two of the methods considered for implementing the closest vector problem in this application. Both use Hamming distance as a metric of `closeness'. However, due to issues implementing Trugenberger's method (Section~\ref{sec:hamming_distance_trugenberger_method}), the alternative method using controlled rotation operators and post-selection based computation was used instead (Section~\ref{sec:hamming_distance_cry_rotation}).


\subsubsection{Hamming Distance - Trugenberger Method}
\label{sec:hamming_distance_trugenberger_method}
A promising method for adjusting the amplitude of a state according to its binary difference to a test vector was proposed by Trugenberger~\cite{Trugenberger_2001, Trugenberger_2002} and is detailed in Deliverable 1.1 Section 3.3. However, due to constraints in this algorithm, it was not possible to implement this method in the allocated time. Specifically, the issue lay in decomposing the exponential of a Hamiltonian across different states which is a costly requirement. Thus, due to the complexity of the problem, and the overhead of the added execution time of the necessary simulation, it was decided to implement an alternative method to compute the closest vector problem.

\subsubsection{Hamming Distance - Controlled rotation operator about $\hat{y}$ (\textrm{$R_y$}) }
\label{sec:hamming_distance_cry_rotation}

The alternative implemented method was proposed and outlined in Appendix C of Deliverable 1.1. This method involves calculating the binary difference between the target state's qubits and a test vector's, storing the difference as 1 if they are the same in the state's memory register, else 0 (ie. Hamming distance). A $y$-rotation about an angle $\theta = \frac{\pi}{n}$ is then conducted for each bit set in the memory register (using a controlled $y$ rotation) on a single ancillary qubit $\vert u \rangle$ initialised as $\vert 0 \rangle$. The storing of the Hamming distance in the memory register $\vert m \rangle$ is then `un-computed'. The rotation adjusts the amplitude of the corresponding state, bringing it closer to $\vert 1 \rangle$ for each rotation conducted.

The algorithm deviates slightly from the above and is implemented as follows. The algorithm assumes that we already have $N$ states of length $n$ encoded into the memory register $\vert m \rangle$ of a superposition of states. The algorithm requires $2n+1$ qubits; $n$ qubits to store the test pattern in a register $\vert p \rangle$, a one qubit ancilla register $\vert u \rangle$ which the rotations will act on, and $n$ qubits for the memory register $\vert m \rangle$ which are already initialised with the training patterns. Registers $\vert p \rangle$ and $\vert u \rangle$ are initialised as all $0$'s. Hence, our initial state is

\begin{align}
    \vert \psi_0 \rangle &= \frac{1}{\sqrt{N}}\sum\limits_{i=1}^{N} \vert p \rangle \vert u \rangle \vert m \rangle \\
    &= \frac{1}{\sqrt{N}}\sum\limits_{i=1}^{N} \vert 0_{1}\dots 0_{n} \rangle\vert 0 \rangle \vert p_1^{i}\dots p_n^{i} \rangle .
\end{align}

Next, the test pattern $\{x_1,\dots,x_n\}$ is encoded into the register $\vert p \rangle$ sequentially by applying a \textrm{NOT} gate to each qubit whose corresponding classical bit $x_i$ is set;

\begin{align}
    \vert \psi_1 \rangle = \frac{1}{\sqrt{N}}\sum\limits_{i=1}^{N} \vert x_{1}\dots x_{n} \rangle\vert 0 \rangle \vert p_1^{i}\dots p_n^{i} \rangle .
\end{align}

Rather than overwriting register $\vert m\rangle$ with the Hamming distance, a two qubit controlled unitary is applied if the two corresponding qubits match, such that the unitary matrix \textrm{U} $ = $ \textrm{$R_y$}$(\theta = \frac{\pi}{n})$. This is done by iteratively applying the following process on each qubit in $\vert p \rangle$ and $\vert m \rangle$ for $j = 1,\dots,n$. 

Apply the n-qubit controlled unitary (\textrm{nCU}) gate with $p_j$ and $m_j$ as control qubits to rotate $\vert u \rangle$ if both control qubits are set;

\begin{align}
\label{eq:hamming_ncu1}
    \vert \psi_2 \rangle =  \prod\limits_{j=1}^{n} \textrm{nCU}_{p_j m_j u} \vert \psi_1 \rangle ,
\end{align}
\noindent where
\begin{align}
\label{eq:hamming_ncu_U}
    \textrm{U} &= e^{-\imath \frac{\theta \sigma_y }{2}} \\
    &=
    \begin{bmatrix}
    \cos\left(\frac{\theta}{2}\right) & -\sin\left(\frac{\theta}{2}\right) \\
    \sin\left(\frac{\theta}{2}\right)  & \cos\left(\frac{\theta}{2}\right)
    \end{bmatrix}.
\end{align}

Each of the control qubits used are flipped and the \textrm{nCU} gate is applied again, to check for when the original values of $p_j$ and $m_j$ are both $0$;

\begin{align}
    \vert \psi_3 \rangle &=  \prod\limits_{j=1}^{n} \textrm{NOT}_{p_j}\textrm{NOT}_{m_j} \vert \psi_2 \rangle,\\
    \vert \psi_4 \rangle &=  \prod\limits_{j=1}^{n} \textrm{nCU}_{p_j m_j u} \vert \psi_3 \rangle , 
\end{align}

\noindent with \textrm{U} as shown in equation \eqref{eq:hamming_ncu_U}. Otherwise, if $p_j$ and $m_j$ are different values, then no rotation is applied. 

The two \textrm{NOT} gates that were applied are then `uncomputed';

\begin{align}
    \vert \psi_5 \rangle &=  \prod\limits_{j=n}^{1} \textrm{NOT}_{p_j}\textrm{NOT}_{m_j} \vert \psi_4 \rangle.
    \label{eq:hamming_uncompute}
\end{align}

Finally, the test vector stored in register $\vert p \rangle$ is reset to consist of all $0$'s by applying a \textrm{NOT} gate to each qubit in $\vert p \rangle$ whose corresponding classical bit is set to $1$.

Note, equations \eqref{eq:hamming_ncu1} - \eqref{eq:hamming_uncompute} can be rewritten as a single expression;

\begin{align}
    \label{eq:hamming_complete_alg}
    \vert \psi_2^{\prime} \rangle = \prod\limits_{j=1}^{n} \textrm{NOT}_{p_j}\textrm{NOT}_{m_j}  \textrm{nCU}_{p_j m_j u} \textrm{NOT}_{p_j}\textrm{NOT}_{m_j} \textrm{nCU}_{p_j m_j u} \vert \psi_1 \rangle,
\end{align}

\noindent with \textrm{U} as shown in equation \eqref{eq:hamming_ncu_U}. This single expression form of the algorithm in equation \eqref{eq:hamming_complete_alg} is the version implemented in the application. The product over $j$ is mapped to the implementation by looping the operations within the product term in equation \eqref{eq:hamming_complete_alg} over the product term's indices. 

The result of this algorithm is a superposition of states with the training patterns stored in register $\vert m \rangle$, and the amplitude of each state set according to its Hamming distance to the test pattern $\{x_1,\dots,x_n\}$. This superposition with adjusted amplitudes can then be used as an input to another algorithm, however for the purpose of this application, meaningful results can be obtained by applying post-selection and then measurement to the superposition. This is described in Sections \ref{sec:post_selection} and \ref{sec:measurement}.


\subsection{Post-Selection}
\label{sec:post_selection}
As detailed in Section \ref{sec:hamming_distance_cry_rotation}, a superposition of states can be prepared and the amplitudes for each state adjusted to reflect its binary pattern's `closeness' to a specified test pattern.

In order to conduct measurements on this superposition to get meaningful results, the ancilla qubit in register $\vert u \rangle$ about which the rotations were conducted, needs to be collapsed to the state $\vert 1 \rangle$. This conditioning of a measurement on another qubit (in this case $\vert u \rangle$) is referred to as `post-selection'. 

The reason that post-selection is necessary, is that upon applying a rotation to register $\vert u \rangle = \vert 0 \rangle$, this register becomes a superposition of the state $\vert u \rangle = \alpha\vert 0 \rangle + \beta \vert 1 \rangle$, where $\left| \alpha \right|^2 + \left|\beta\right|^2 = 1$. This entangles the encoded data with the state $\vert u \rangle$, with degree depending upon the Hamming distance (ie. the number of rotations taken). Thus, to obtain meaningful information about the Hamming distance after measurement of the state, the qubit in register $\vert 0 \rangle$ must be collapsed so that we are left with either $\alpha \vert 0\rangle$ or $\beta \vert 1\rangle$. Since the closeness of the qubit to $\vert 1\rangle$ is the desired information, it is clear that $\vert u \rangle$ must be collapsed to $\vert 1\rangle$, as smaller Hamming distance values (larger binary patterns) will rotate the state further towards $\vert 1\rangle$. By projecting $\vert u \rangle$ onto $\vert 1 \rangle$ we obtain states with amplitudes directly influenced by their Hamming distance.

\subsection{Measurement}
\label{sec:measurement}
Now that the states each have their respective Hamming distance directly encoded into its amplitude, a measurement on each qubit in the memory register $\vert m \rangle$ is applied to obtain a single state. Note, that in Section \ref{sec:post_selection} post-selection collapsed a qubit to a specific state, whether in these measurements a qubit is collapsed randomly but weighted by its amplitude.

The entire experiment is then repeated from the beginning, and another measurement conducted. This `shot' based method is conducted many times in order to create a distribution of the occurrences of each state, and hence the probability of each state being measured. This distribution quantifies the relative closeness of that state's training pattern to the test pattern. Thus, demonstrating a reliable method to implementing the `closest vector problem'.

Furthermore, the number of set bits in the Hamming distance can be obtained by performing some simple reverse computation on the probability of a state being measured. In order to do this, the relationship between the number of rotations applied and amplitude must be derived.

In section \ref{sec:hamming_distance_cry_rotation}, consider the case were a $y$-rotation is applied $r$ times to $\vert 0 \rangle$ for a given state.

\begin{align}
    R_y\left(\theta\right) \vert 0 \rangle &= 
    \begin{bmatrix}
        \cos\left(\frac{\theta}{2}\right) & -\sin\left(\frac{\theta}{2}\right)\\
        \sin\left(\frac{\theta}{2}\right) & cos\left(\frac{\theta}{2}\right)
    \end{bmatrix}
    \begin{bmatrix}
    1 \\ 0 
    \end{bmatrix}\\
    &= \cos\left(\frac{\theta}{2}\right)    
    \begin{bmatrix}
    1 \\ 0 
    \end{bmatrix}
    + \sin\left(\frac{\theta}{2}\right)
    \begin{bmatrix}
    1 \\ 0 
    \end{bmatrix}\\
    &= \cos\left(\frac{\theta}{2}\right) \vert 0 \rangle + \sin\left(\frac{\theta}{2}\right) \vert 1 \rangle.
    \label{eq:rotation_on_0}
\end{align}

\noindent Similarly for $\vert 1 \rangle$,
\begin{align}
    R_y\left(\theta\right) \vert 1 \rangle &= 
    \begin{bmatrix}
        \cos\left(\frac{\theta}{2}\right) & -\sin\left(\frac{\theta}{2}\right)\\
        \sin\left(\frac{\theta}{2}\right) & cos\left(\frac{\theta}{2}\right)
    \end{bmatrix}
    \begin{bmatrix}
    0 \\ 1 
    \end{bmatrix}\\
    &= -\sin\left(\frac{\theta}{2}\right)    
    \begin{bmatrix}
    1 \\ 0 
    \end{bmatrix}
    + \cos\left(\frac{\theta}{2}\right)
    \begin{bmatrix}
    1 \\ 0 
    \end{bmatrix}\\
    &= -\sin\left(\frac{\theta}{2}\right) \vert 0 \rangle + \cos\left(\frac{\theta}{2}\right) \vert 1 \rangle.
        \label{eq:rotation_on_1}
\end{align}

The rotation is initially applied to the state $\vert 0 \rangle$, resulting in equation \eqref{eq:rotation_on_0}. Applying a second rotation on the register $\vert u \rangle$ for that same state gives

\begin{align}
    \left(R_y\left(\theta \right)\right)^2 \vert 0 \rangle 
    &=
    R_y\left(\theta \right) \left( \cos\left(\frac{\theta}{2}\right) \vert 0 \rangle + \sin\left(\frac{\theta}{2}\right) \vert 1 \rangle\right) \\
    &=
    \cos\left(\frac{\theta}{2}\right) R_y\left(\theta \right)\vert 0 \rangle + \sin\left(\frac{\theta}{2}\right) R_y\left(\theta \right)\vert 1 \rangle\\
    &=
    \cos\left(\frac{\theta}{2}\right)\left[\cos\left(\frac{\theta}{2}\right)\vert 0 \rangle + \sin\left(\frac{\theta}{2}\right)\vert 1 \rangle \right]\\
    &+ \sin\left(\frac{\theta}{2}\right)\left[-\sin\left(\frac{\theta}{2}\right)\vert 0 \rangle + \cos\left(\frac{\theta}{2}\right)\vert 1 \rangle \right]\\
    &= \cos\left(\theta\right)\vert 0 \rangle + \sin\left(\theta\right)\vert 1 \rangle 
    \label{eq:second_rotation}.
\end{align}

$ R_y\left(\theta \right) $ can be applied $r$ times to the initial state $\vert 0 \rangle$ which results in

\begin{align}
    \left(R_y\left(\theta \right)\right) ^r \vert 0 \rangle 
    =
    \cos\left(\frac{r\theta}{2}\right)\vert 0 \rangle + \sin\left(\frac{r\theta}{2}\right)\vert 1 \rangle 
\end{align}

In the case of the Hamming distance method described in Section \ref{sec:hamming_distance_cry_rotation} $\theta = \frac{\pi}{n}$, thus for a given state that has a register $\vert u \rangle$ initially as $\vert 0 \rangle$,

\begin{align}
    \left(R_y\left(\frac{\pi}{n} \right)\right) ^r \vert u \rangle 
    &=
    \left(R_y\left(\frac{\pi}{n} \right)\right) ^r \vert 0 \rangle\\
    &=
    \cos\left(\frac{r\pi}{2n}\right)\vert 0 \rangle + \sin\left(\frac{r\pi}{2n}\right)\vert 1 \rangle,        
\end{align}

\noindent and after post-selection;

\begin{align}
    \vert 1 \rangle \langle 1\vert \left(R_y\left(\frac{\pi}{n} \right)\right) ^r \vert u \rangle
    =
    \sin\left(\frac{r\pi}{2n}\right)\vert 1 \rangle.        
\end{align}

In terms of the superposition of states after the Hamming distance and post-selection is applied,

\begin{align*}
    \vert \psi \rangle = \frac{1}{\sqrt{\sum\limits_{i=1}^{N} \left| \sin\left( \frac{r_i\pi}{2n} \right)\right|^2}}\sum\limits_{i=1}^{N} \sin\left(\frac{r_i\pi}{2n}\right) \vert 0_{1}\dots 0_{n} \rangle\vert 1 \rangle \vert p_1^{i}\dots p_n^{i} \rangle ,
\end{align*}

\noindent where $r_i$ is the number of rotations applied to $\vert u\rangle$ on the $i^{\textrm{th}}$ state. Thus, the probability for a randomly measured state with index $k$ being measured is,

\begin{align}
    \mathcal{P}\left( \vert m \rangle = \vert p^k \rangle \right) 
    =
    \frac{\sin^2\left(\frac{r_k\pi}{2n}\right)}{\sum\limits_{i=1}^{N}  \sin^2\left( \frac{r_i\pi}{2n} \right)}.
\end{align}

\iffalse

\noindent From this we can compute the binary distance $r_k$;

\begin{align}
    r_k = \frac{2n}{\pi}\sin^{-1}\left( \sqrt{\frac{\mathcal{P}\left( \vert m \rangle = \vert p^i \rangle \right)}{1-\mathcal{P}\left( \vert m \rangle = \vert p^i \rangle \right)}\displaystyle\sum\limits_{\substack{i=1\\ i\neq k}}^{N}  \sin^2\left( \frac{r_i\pi}{2n} \right) } \right).
\end{align}
\fi 