<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QNLP: QNLP::SimulatorGeneral&lt; DerivedType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">QNLP
   &#160;<span id="projectnumber">v1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a00932.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">QNLP::SimulatorGeneral&lt; DerivedType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>CRTP defined class for simulator implementations.  
 <a href="a00932.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00173_source.html">Simulator.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for QNLP::SimulatorGeneral&lt; DerivedType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="a00931.png" border="0" usemap="#_q_n_l_p_1_1_simulator_general_3_01_derived_type_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="_q_n_l_p_1_1_simulator_general_3_01_derived_type_01_4_inherit__map" id="_q_n_l_p_1_1_simulator_general_3_01_derived_type_01_4_inherit__map">
<area shape="rect"  title="CRTP defined class for simulator implementations." alt="" coords="5,5,245,963"/>
<area shape="rect"  href="a00932.html" title=" " alt="" coords="5,1025,245,1983"/>
<area shape="rect"  href="a00924.html" title="Class definition for IntelSimulator. The purpose of this class is to map the functionality of the und..." alt="" coords="37,2032,214,2813"/>
<area shape="rect"  href="a00836.html" title=" " alt="" coords="28,2863,223,3043"/>
</map>
</div>
<div class="dynheader">
Collaboration diagram for QNLP::SimulatorGeneral&lt; DerivedType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="a00930.png" border="0" usemap="#_q_n_l_p_1_1_simulator_general_3_01_derived_type_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="_q_n_l_p_1_1_simulator_general_3_01_derived_type_01_4_coll__map" id="_q_n_l_p_1_1_simulator_general_3_01_derived_type_01_4_coll__map">
<area shape="rect"  title="CRTP defined class for simulator implementations." alt="" coords="5,5,245,963"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6f0890bf195c53a3a9153f0eb25b6486"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a6f0890bf195c53a3a9153f0eb25b6486">~SimulatorGeneral</a> ()</td></tr>
<tr class="memdesc:a6f0890bf195c53a3a9153f0eb25b6486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the Simulator General object.  <a href="#a6f0890bf195c53a3a9153f0eb25b6486">More...</a><br /></td></tr>
<tr class="separator:a6f0890bf195c53a3a9153f0eb25b6486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4359d766497887ac5a48a1d245a1213"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#ac4359d766497887ac5a48a1d245a1213">applyGateX</a> (std::size_t qubit_idx)</td></tr>
<tr class="memdesc:ac4359d766497887ac5a48a1d245a1213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the Pauli X gate to the given qubit.  <a href="#ac4359d766497887ac5a48a1d245a1213">More...</a><br /></td></tr>
<tr class="separator:ac4359d766497887ac5a48a1d245a1213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaee0fc26c962053d4279b6df07a94b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#afaee0fc26c962053d4279b6df07a94b2">applyGateY</a> (std::size_t qubit_idx)</td></tr>
<tr class="memdesc:afaee0fc26c962053d4279b6df07a94b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the Pauli Y gate to the given qubit.  <a href="#afaee0fc26c962053d4279b6df07a94b2">More...</a><br /></td></tr>
<tr class="separator:afaee0fc26c962053d4279b6df07a94b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5201daf966d9261c6c18939d8f70338"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#af5201daf966d9261c6c18939d8f70338">applyGateZ</a> (std::size_t qubit_idx)</td></tr>
<tr class="memdesc:af5201daf966d9261c6c18939d8f70338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the Pauli Z gate to the given qubit.  <a href="#af5201daf966d9261c6c18939d8f70338">More...</a><br /></td></tr>
<tr class="separator:af5201daf966d9261c6c18939d8f70338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35375a9e4e73e0fe1073cf833a33fda4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a35375a9e4e73e0fe1073cf833a33fda4">applyGateI</a> (std::size_t qubit_idx)</td></tr>
<tr class="memdesc:a35375a9e4e73e0fe1073cf833a33fda4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the Identity gate to the given qubit.  <a href="#a35375a9e4e73e0fe1073cf833a33fda4">More...</a><br /></td></tr>
<tr class="separator:a35375a9e4e73e0fe1073cf833a33fda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1bd53ebb7b9be3ee37ff1a5700d3ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#ada1bd53ebb7b9be3ee37ff1a5700d3ac">applyGateH</a> (std::size_t qubit_idx)</td></tr>
<tr class="memdesc:ada1bd53ebb7b9be3ee37ff1a5700d3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the Hadamard gate to the given qubit.  <a href="#ada1bd53ebb7b9be3ee37ff1a5700d3ac">More...</a><br /></td></tr>
<tr class="separator:ada1bd53ebb7b9be3ee37ff1a5700d3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82e3157659365e42adeb1086c15050f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#aa82e3157659365e42adeb1086c15050f">applyGateSqrtX</a> (std::size_t qubit_idx)</td></tr>
<tr class="memdesc:aa82e3157659365e42adeb1086c15050f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the Sqrt{Pauli X} gate to the given qubit.  <a href="#aa82e3157659365e42adeb1086c15050f">More...</a><br /></td></tr>
<tr class="separator:aa82e3157659365e42adeb1086c15050f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e45ecfec7bf9da83750f7a3a671dd9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a8e45ecfec7bf9da83750f7a3a671dd9d">applyGateRotX</a> (std::size_t qubit_idx, double angle_rad)</td></tr>
<tr class="memdesc:a8e45ecfec7bf9da83750f7a3a671dd9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the given Rotation about X-axis to the given qubit.  <a href="#a8e45ecfec7bf9da83750f7a3a671dd9d">More...</a><br /></td></tr>
<tr class="separator:a8e45ecfec7bf9da83750f7a3a671dd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdf0e4f4d0cdad91178e44336963fa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#abbdf0e4f4d0cdad91178e44336963fa7">applyGateRotY</a> (std::size_t qubit_idx, double angle_rad)</td></tr>
<tr class="memdesc:abbdf0e4f4d0cdad91178e44336963fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the given Rotation about Y-axis to the given qubit.  <a href="#abbdf0e4f4d0cdad91178e44336963fa7">More...</a><br /></td></tr>
<tr class="separator:abbdf0e4f4d0cdad91178e44336963fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b45faaf1e972ea9f3501e040014a55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#ad6b45faaf1e972ea9f3501e040014a55">applyGateRotZ</a> (std::size_t qubit_idx, double angle_rad)</td></tr>
<tr class="memdesc:ad6b45faaf1e972ea9f3501e040014a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the given Rotation about Z-axis to the given qubit.  <a href="#ad6b45faaf1e972ea9f3501e040014a55">More...</a><br /></td></tr>
<tr class="separator:ad6b45faaf1e972ea9f3501e040014a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11efa58599dc066c15e376465649c4e"><td class="memTemplParams" colspan="2">template&lt;class Mat2x2Type &gt; </td></tr>
<tr class="memitem:ad11efa58599dc066c15e376465649c4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00932.html#ad11efa58599dc066c15e376465649c4e">applyGateU</a> (const Mat2x2Type &amp;U, std::size_t qubit_idx)</td></tr>
<tr class="memdesc:ad11efa58599dc066c15e376465649c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply arbitrary user-defined unitary gate to qubit at qubit_idx.  <a href="#ad11efa58599dc066c15e376465649c4e">More...</a><br /></td></tr>
<tr class="separator:ad11efa58599dc066c15e376465649c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5732630b0afeecf7fb7e7add27ff0c53"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a5732630b0afeecf7fb7e7add27ff0c53">getGateX</a> ()</td></tr>
<tr class="memdesc:a5732630b0afeecf7fb7e7add27ff0c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Pauli-X gate; returns templated type GateType.  <a href="#a5732630b0afeecf7fb7e7add27ff0c53">More...</a><br /></td></tr>
<tr class="separator:a5732630b0afeecf7fb7e7add27ff0c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f917c600b5f8e6e3275103eadcb021"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a77f917c600b5f8e6e3275103eadcb021">getGateY</a> ()</td></tr>
<tr class="memdesc:a77f917c600b5f8e6e3275103eadcb021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Pauli-Y gate; must be overloaded with appropriate return type.  <a href="#a77f917c600b5f8e6e3275103eadcb021">More...</a><br /></td></tr>
<tr class="separator:a77f917c600b5f8e6e3275103eadcb021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbad6cae3fc4dbb3574bb110487e6b4"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a1cbad6cae3fc4dbb3574bb110487e6b4">getGateZ</a> ()</td></tr>
<tr class="memdesc:a1cbad6cae3fc4dbb3574bb110487e6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Pauli-Z gate; must be overloaded with appropriate return type.  <a href="#a1cbad6cae3fc4dbb3574bb110487e6b4">More...</a><br /></td></tr>
<tr class="separator:a1cbad6cae3fc4dbb3574bb110487e6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9aec8749122ab1ea137c9a78a6273a4"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#ae9aec8749122ab1ea137c9a78a6273a4">getGateI</a> ()</td></tr>
<tr class="memdesc:ae9aec8749122ab1ea137c9a78a6273a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Identity; must be overloaded with appropriate return type.  <a href="#ae9aec8749122ab1ea137c9a78a6273a4">More...</a><br /></td></tr>
<tr class="separator:ae9aec8749122ab1ea137c9a78a6273a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42dcb1233908b2ecaba3d9a1d0dfb77"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#af42dcb1233908b2ecaba3d9a1d0dfb77">getGateH</a> ()</td></tr>
<tr class="memdesc:af42dcb1233908b2ecaba3d9a1d0dfb77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Hadamard gate; must be overloaded with appropriate return type.  <a href="#af42dcb1233908b2ecaba3d9a1d0dfb77">More...</a><br /></td></tr>
<tr class="separator:af42dcb1233908b2ecaba3d9a1d0dfb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d536516bf3a71c776d97e974347d43"><td class="memTemplParams" colspan="2">template&lt;class Mat2x2Type &gt; </td></tr>
<tr class="memitem:a78d536516bf3a71c776d97e974347d43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00932.html#a78d536516bf3a71c776d97e974347d43">applyGateCU</a> (const Mat2x2Type &amp;U, const std::size_t control, const std::size_t target, std::string label=&quot;CU&quot;)</td></tr>
<tr class="memdesc:a78d536516bf3a71c776d97e974347d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the given controlled unitary gate on target qubit.  <a href="#a78d536516bf3a71c776d97e974347d43">More...</a><br /></td></tr>
<tr class="separator:a78d536516bf3a71c776d97e974347d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bc894a2c0b0fd29bcbf8182ba27a3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a21bc894a2c0b0fd29bcbf8182ba27a3b">applyGateCX</a> (const std::size_t control, const std::size_t target)</td></tr>
<tr class="memdesc:a21bc894a2c0b0fd29bcbf8182ba27a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply Controlled Pauli-X (CNOT) on target qubit.  <a href="#a21bc894a2c0b0fd29bcbf8182ba27a3b">More...</a><br /></td></tr>
<tr class="separator:a21bc894a2c0b0fd29bcbf8182ba27a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06d08514aca47c3c4f29ba5d450feb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#af06d08514aca47c3c4f29ba5d450feb6">applyGateCY</a> (const std::size_t control, const std::size_t target)</td></tr>
<tr class="memdesc:af06d08514aca47c3c4f29ba5d450feb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply Controlled Pauli-Y on target qubit.  <a href="#af06d08514aca47c3c4f29ba5d450feb6">More...</a><br /></td></tr>
<tr class="separator:af06d08514aca47c3c4f29ba5d450feb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43f726f5d65edc5d074306bc9f6d27a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#af43f726f5d65edc5d074306bc9f6d27a">applyGateCZ</a> (const std::size_t control, const std::size_t target)</td></tr>
<tr class="memdesc:af43f726f5d65edc5d074306bc9f6d27a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply Controlled Pauli-Z on target qubit.  <a href="#af43f726f5d65edc5d074306bc9f6d27a">More...</a><br /></td></tr>
<tr class="separator:af43f726f5d65edc5d074306bc9f6d27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4363d9df7109c2d57b15746507ecf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#aec4363d9df7109c2d57b15746507ecf5">applyGateCH</a> (const std::size_t control, const std::size_t target)</td></tr>
<tr class="memdesc:aec4363d9df7109c2d57b15746507ecf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply Controlled Hadamard on target qubit.  <a href="#aec4363d9df7109c2d57b15746507ecf5">More...</a><br /></td></tr>
<tr class="separator:aec4363d9df7109c2d57b15746507ecf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d968b4660a5a095825c8139abc5bdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#ab5d968b4660a5a095825c8139abc5bdd">applyGateSwap</a> (std::size_t qubit_idx0, std::size_t qubit_idx1)</td></tr>
<tr class="memdesc:ab5d968b4660a5a095825c8139abc5bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the qubits at the given indices.  <a href="#ab5d968b4660a5a095825c8139abc5bdd">More...</a><br /></td></tr>
<tr class="separator:ab5d968b4660a5a095825c8139abc5bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a5b3cf59b4138390aa6ed9b5bc8091"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a98a5b3cf59b4138390aa6ed9b5bc8091">applyGateSqrtSwap</a> (std::size_t qubit_idx0, std::size_t qubit_idx1)</td></tr>
<tr class="memdesc:a98a5b3cf59b4138390aa6ed9b5bc8091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs Sqrt SWAP gate between two given qubits (half way SWAP)  <a href="#a98a5b3cf59b4138390aa6ed9b5bc8091">More...</a><br /></td></tr>
<tr class="separator:a98a5b3cf59b4138390aa6ed9b5bc8091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365ed045daa5b15b3ebc71afe29e35b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a365ed045daa5b15b3ebc71afe29e35b8">applyGatePhaseShift</a> (double angle, std::size_t qubit_idx)</td></tr>
<tr class="memdesc:a365ed045daa5b15b3ebc71afe29e35b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply phase shift to given Qubit; [[1 0] [0 exp(i*angle)]].  <a href="#a365ed045daa5b15b3ebc71afe29e35b8">More...</a><br /></td></tr>
<tr class="separator:a365ed045daa5b15b3ebc71afe29e35b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3479e8edbd4bb56b68d27a57057b9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a0e3479e8edbd4bb56b68d27a57057b9e">applyGateCPhaseShift</a> (double angle, std::size_t control, std::size_t target)</td></tr>
<tr class="memdesc:a0e3479e8edbd4bb56b68d27a57057b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform controlled phase shift gate.  <a href="#a0e3479e8edbd4bb56b68d27a57057b9e">More...</a><br /></td></tr>
<tr class="separator:a0e3479e8edbd4bb56b68d27a57057b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09d709544b5fe78942622e7f567399a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#aa09d709544b5fe78942622e7f567399a">applyGateCCX</a> (std::size_t ctrl_qubit0, std::size_t ctrl_qubit1, std::size_t target_qubit)</td></tr>
<tr class="memdesc:aa09d709544b5fe78942622e7f567399a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controlled controlled NOT (CCNOT, CCX) gate.  <a href="#aa09d709544b5fe78942622e7f567399a">More...</a><br /></td></tr>
<tr class="separator:aa09d709544b5fe78942622e7f567399a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c00b65cc011c4a6bf0478e9d4a7edf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#ac3c00b65cc011c4a6bf0478e9d4a7edf">applyGateCSwap</a> (std::size_t ctrl_qubit, std::size_t qubit_swap0, std::size_t qubit_swap1)</td></tr>
<tr class="memdesc:ac3c00b65cc011c4a6bf0478e9d4a7edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controlled SWAP gate.  <a href="#ac3c00b65cc011c4a6bf0478e9d4a7edf">More...</a><br /></td></tr>
<tr class="separator:ac3c00b65cc011c4a6bf0478e9d4a7edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec7eac350b2da8a2b0bcb05e4cd8a3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a3ec7eac350b2da8a2b0bcb05e4cd8a3f">applyGateCRotX</a> (std::size_t ctrl_qubit, std::size_t qubit_idx, double angle_rad)</td></tr>
<tr class="memdesc:a3ec7eac350b2da8a2b0bcb05e4cd8a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the given Controlled Rotation about X-axis to the given qubit.  <a href="#a3ec7eac350b2da8a2b0bcb05e4cd8a3f">More...</a><br /></td></tr>
<tr class="separator:a3ec7eac350b2da8a2b0bcb05e4cd8a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b08ec373fc8b181cf9d628483f11a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a31b08ec373fc8b181cf9d628483f11a0">applyGateCRotY</a> (std::size_t ctrl_qubit, std::size_t qubit_idx, double angle_rad)</td></tr>
<tr class="memdesc:a31b08ec373fc8b181cf9d628483f11a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the given Controlled Rotation about Y-axis to the given qubit.  <a href="#a31b08ec373fc8b181cf9d628483f11a0">More...</a><br /></td></tr>
<tr class="separator:a31b08ec373fc8b181cf9d628483f11a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b519b081690689fbf838d5680d2a007"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a2b519b081690689fbf838d5680d2a007">applyGateCRotZ</a> (std::size_t ctrl_qubit, std::size_t qubit_idx, double angle_rad)</td></tr>
<tr class="memdesc:a2b519b081690689fbf838d5680d2a007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the given Controlled Rotation about Z-axis to the given qubit.  <a href="#a2b519b081690689fbf838d5680d2a007">More...</a><br /></td></tr>
<tr class="separator:a2b519b081690689fbf838d5680d2a007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9e49aa9ced48d248d6d81a6f7b7a54"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a8d9e49aa9ced48d248d6d81a6f7b7a54">getQubitRegister</a> ()</td></tr>
<tr class="memdesc:a8d9e49aa9ced48d248d6d81a6f7b7a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying qubit register object.  <a href="#a8d9e49aa9ced48d248d6d81a6f7b7a54">More...</a><br /></td></tr>
<tr class="separator:a8d9e49aa9ced48d248d6d81a6f7b7a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106178245fff70419c4de79b26592ba3"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a106178245fff70419c4de79b26592ba3">getNumQubits</a> ()</td></tr>
<tr class="memdesc:a106178245fff70419c4de79b26592ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of Qubits.  <a href="#a106178245fff70419c4de79b26592ba3">More...</a><br /></td></tr>
<tr class="separator:a106178245fff70419c4de79b26592ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01cf864ddcce63c22be913097f347b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#ae01cf864ddcce63c22be913097f347b0">applyQFT</a> (std::size_t minIdx, std::size_t maxIdx)</td></tr>
<tr class="memdesc:ae01cf864ddcce63c22be913097f347b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the forward Quantum Fourier transform (<a class="el" href="a00808.html" title="Class definition for performing quantum forward and inverse Fourier transforms.">QFT</a>) to the given register index range.  <a href="#ae01cf864ddcce63c22be913097f347b0">More...</a><br /></td></tr>
<tr class="separator:ae01cf864ddcce63c22be913097f347b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addefd63a2c9fa6136bc8c289482fedf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#addefd63a2c9fa6136bc8c289482fedf1">applyIQFT</a> (std::size_t minIdx, std::size_t maxIdx)</td></tr>
<tr class="memdesc:addefd63a2c9fa6136bc8c289482fedf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the inverse Quantum Fourier transform (IQFT) to the given register index range.  <a href="#addefd63a2c9fa6136bc8c289482fedf1">More...</a><br /></td></tr>
<tr class="separator:addefd63a2c9fa6136bc8c289482fedf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67847e4b34c222c49e0466ccdc8961c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a67847e4b34c222c49e0466ccdc8961c9">sumReg</a> (std::size_t r0_minIdx, std::size_t r0_maxIdx, std::size_t r1_minIdx, std::size_t r1_maxIdx)</td></tr>
<tr class="memdesc:a67847e4b34c222c49e0466ccdc8961c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies |r1&gt;|r2&gt; -&gt; |r1&gt;|r1+r2&gt;  <a href="#a67847e4b34c222c49e0466ccdc8961c9">More...</a><br /></td></tr>
<tr class="separator:a67847e4b34c222c49e0466ccdc8961c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf21cf93cffc21565d1708f7362a238e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#acf21cf93cffc21565d1708f7362a238e">subReg</a> (std::size_t r0_minIdx, std::size_t r0_maxIdx, std::size_t r1_minIdx, std::size_t r1_maxIdx)</td></tr>
<tr class="memdesc:acf21cf93cffc21565d1708f7362a238e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies |r1&gt;|r2&gt; -&gt; |r1&gt;|r1-r2&gt;  <a href="#acf21cf93cffc21565d1708f7362a238e">More...</a><br /></td></tr>
<tr class="separator:acf21cf93cffc21565d1708f7362a238e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913db3f649fd704afcf75f4f8e9789de"><td class="memTemplParams" colspan="2">template&lt;class Mat2x2Type &gt; </td></tr>
<tr class="memitem:a913db3f649fd704afcf75f4f8e9789de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00932.html#a913db3f649fd704afcf75f4f8e9789de">applyGateNCU</a> (const Mat2x2Type &amp;U, const std::vector&lt; std::size_t &gt; &amp;ctrlIndices, std::size_t target, std::string label)</td></tr>
<tr class="memdesc:a913db3f649fd704afcf75f4f8e9789de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply n-control unitary gate to the given qubit target.  <a href="#a913db3f649fd704afcf75f4f8e9789de">More...</a><br /></td></tr>
<tr class="separator:a913db3f649fd704afcf75f4f8e9789de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b264c7e265e918011016acfcff1b70"><td class="memTemplParams" colspan="2">template&lt;class Mat2x2Type &gt; </td></tr>
<tr class="memitem:ac1b264c7e265e918011016acfcff1b70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00932.html#ac1b264c7e265e918011016acfcff1b70">applyGateNCU</a> (const Mat2x2Type &amp;U, const std::vector&lt; std::size_t &gt; &amp;ctrlIndices, const std::vector&lt; std::size_t &gt; &amp;auxIndices, std::size_t target, std::string label)</td></tr>
<tr class="memdesc:ac1b264c7e265e918011016acfcff1b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply n-control sigma_x gate to the given qubit target, using auxiliary qubits for 5CX optimisation.  <a href="#ac1b264c7e265e918011016acfcff1b70">More...</a><br /></td></tr>
<tr class="separator:ac1b264c7e265e918011016acfcff1b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63bd0c42ec6867678ada3d48866cd49"><td class="memTemplParams" colspan="2">template&lt;class Mat2x2Type &gt; </td></tr>
<tr class="memitem:af63bd0c42ec6867678ada3d48866cd49"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00932.html#af63bd0c42ec6867678ada3d48866cd49">applyOracleU</a> (std::size_t bit_pattern, const std::vector&lt; std::size_t &gt; &amp;ctrlIndices, std::size_t target, const Mat2x2Type &amp;U, std::string gateLabel)</td></tr>
<tr class="memdesc:af63bd0c42ec6867678ada3d48866cd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply oracle to match given binary index with non adjacent controls.  <a href="#af63bd0c42ec6867678ada3d48866cd49">More...</a><br /></td></tr>
<tr class="separator:af63bd0c42ec6867678ada3d48866cd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04b34a18c2677d36020c9ce688eed1a"><td class="memTemplParams" colspan="2">template&lt;class Mat2x2Type &gt; </td></tr>
<tr class="memitem:af04b34a18c2677d36020c9ce688eed1a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00932.html#af04b34a18c2677d36020c9ce688eed1a">applyOracleU</a> (std::size_t bit_pattern, const std::vector&lt; std::size_t &gt; &amp;ctrlIndices, const std::vector&lt; std::size_t &gt; &amp;auxIndices, std::size_t target, const Mat2x2Type &amp;U, std::string gateLabel)</td></tr>
<tr class="memdesc:af04b34a18c2677d36020c9ce688eed1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply oracle to match given binary index with non adjacent controls.  <a href="#af04b34a18c2677d36020c9ce688eed1a">More...</a><br /></td></tr>
<tr class="separator:af04b34a18c2677d36020c9ce688eed1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99156d389719269b2324aa362d4047e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a99156d389719269b2324aa362d4047e4">applyOraclePhase</a> (std::size_t bit_pattern, const std::vector&lt; std::size_t &gt; &amp;ctrlIndices, std::size_t target)</td></tr>
<tr class="memdesc:a99156d389719269b2324aa362d4047e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply oracle to match given binary index with linearly adjacent controls.  <a href="#a99156d389719269b2324aa362d4047e4">More...</a><br /></td></tr>
<tr class="separator:a99156d389719269b2324aa362d4047e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfa1a862e7bb752f703f0c4234959f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a4cfa1a862e7bb752f703f0c4234959f1">applyDiffusion</a> (const std::vector&lt; std::size_t &gt; &amp;ctrlIndices, std::size_t target)</td></tr>
<tr class="memdesc:a4cfa1a862e7bb752f703f0c4234959f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply diffusion operator on marked state.  <a href="#a4cfa1a862e7bb752f703f0c4234959f1">More...</a><br /></td></tr>
<tr class="separator:a4cfa1a862e7bb752f703f0c4234959f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc0205185d34a8756670fa138666b5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a2cc0205185d34a8756670fa138666b5e">encodeToRegister</a> (std::size_t target_pattern, const std::vector&lt; std::size_t &gt; target_register, std::size_t len_bin_pattern)</td></tr>
<tr class="memdesc:a2cc0205185d34a8756670fa138666b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes a defined binary pattern into a defined target register (initially in state |00...0&gt;) of all quantum states in the superposition.  <a href="#a2cc0205185d34a8756670fa138666b5e">More...</a><br /></td></tr>
<tr class="separator:a2cc0205185d34a8756670fa138666b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203ad2c406b64490353acab47987b21b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a203ad2c406b64490353acab47987b21b">encodeBinToSuperpos_unique</a> (const std::vector&lt; std::size_t &gt; &amp;reg_memory, const std::vector&lt; std::size_t &gt; &amp;reg_auxiliary, const std::vector&lt; std::size_t &gt; &amp;bin_patterns, const std::size_t len_bin_pattern)</td></tr>
<tr class="memdesc:a203ad2c406b64490353acab47987b21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode inputted binary strings to the memory register specified as a superposition of states. Note that this implementation does not allow for multiple instances of the same input pattern but allows for 0 to be encoded.  <a href="#a203ad2c406b64490353acab47987b21b">More...</a><br /></td></tr>
<tr class="separator:a203ad2c406b64490353acab47987b21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879f5f6c2a27305df3b5f0a8ab7552a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a879f5f6c2a27305df3b5f0a8ab7552a9">applyHammingDistanceRotY</a> (std::size_t test_pattern, const std::vector&lt; std::size_t &gt; reg_mem, const std::vector&lt; std::size_t &gt; reg_auxiliary, std::size_t len_bin_pattern)</td></tr>
<tr class="memdesc:a879f5f6c2a27305df3b5f0a8ab7552a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the relative Hamming distance between the test pattern and the pattern stored in each state of the superposition, storing the result in the amplitude of the corresponding state.  <a href="#a879f5f6c2a27305df3b5f0a8ab7552a9">More...</a><br /></td></tr>
<tr class="separator:a879f5f6c2a27305df3b5f0a8ab7552a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62363e702fcea7868324c69a076d60ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a62363e702fcea7868324c69a076d60ea">applyHammingDistanceOverwrite</a> (std::size_t test_pattern, const std::vector&lt; std::size_t &gt; reg_mem, const std::vector&lt; std::size_t &gt; reg_auxiliary, std::size_t len_bin_pattern)</td></tr>
<tr class="memdesc:a62363e702fcea7868324c69a076d60ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the relative Hamming distance between the test pattern and the pattern stored in each state of the superposition, overwriting the aux register pattern with the resulting bit differences.  <a href="#a62363e702fcea7868324c69a076d60ea">More...</a><br /></td></tr>
<tr class="separator:a62363e702fcea7868324c69a076d60ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7e9960c3af1bbce94a8f68eb09ecf2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a6e7e9960c3af1bbce94a8f68eb09ecf2">applyMeasurement</a> (std::size_t target, bool normalize=true)</td></tr>
<tr class="memdesc:a6e7e9960c3af1bbce94a8f68eb09ecf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply measurement to a target qubit, randomly collapsing the qubit proportional to the amplitude and returns the collapsed value.  <a href="#a6e7e9960c3af1bbce94a8f68eb09ecf2">More...</a><br /></td></tr>
<tr class="separator:a6e7e9960c3af1bbce94a8f68eb09ecf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94527f570935fc660405701a6368e271"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a94527f570935fc660405701a6368e271">applyMeasurementToRegister</a> (std::vector&lt; std::size_t &gt; target_qubits, bool normalize=true)</td></tr>
<tr class="memdesc:a94527f570935fc660405701a6368e271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply measurement to a set of target qubits, randomly collapsing the qubits proportional to the amplitude and returns the bit string of the qubits in the order they are represented in the vector of indexes, in the form of an unsigned integer.  <a href="#a94527f570935fc660405701a6368e271">More...</a><br /></td></tr>
<tr class="separator:a94527f570935fc660405701a6368e271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adead1b90156ed331ab4146c27f8ec37f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#adead1b90156ed331ab4146c27f8ec37f">groupQubits</a> (const std::vector&lt; std::size_t &gt; reg_auxiliary, bool lsb=true)</td></tr>
<tr class="memdesc:adead1b90156ed331ab4146c27f8ec37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group all set qubits to MSB in register (ie |010100&gt; -&gt; |000011&gt;)  <a href="#adead1b90156ed331ab4146c27f8ec37f">More...</a><br /></td></tr>
<tr class="separator:adead1b90156ed331ab4146c27f8ec37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb9d8d81ad94adddc1b30e03300e741"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a6eb9d8d81ad94adddc1b30e03300e741">collapseToBasisZ</a> (std::size_t target, bool collapseValue)</td></tr>
<tr class="memdesc:a6eb9d8d81ad94adddc1b30e03300e741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply measurement to a target qubit with respect to the Z-basis, collapsing to a specified value (0 or 1). Amplitudes are r-normalized afterwards.  <a href="#a6eb9d8d81ad94adddc1b30e03300e741">More...</a><br /></td></tr>
<tr class="separator:a6eb9d8d81ad94adddc1b30e03300e741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afa18d6ef2097e820edf366b21943be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a3afa18d6ef2097e820edf366b21943be">initRegister</a> ()</td></tr>
<tr class="memdesc:a3afa18d6ef2097e820edf366b21943be"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Re)Initialise the underlying register of the encapsulated simulator to well-defined state (|0....0&gt;)  <a href="#a3afa18d6ef2097e820edf366b21943be">More...</a><br /></td></tr>
<tr class="separator:a3afa18d6ef2097e820edf366b21943be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363ca18f6710cc1f4bcdb0f4f27aa197"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a363ca18f6710cc1f4bcdb0f4f27aa197">initCaches</a> ()</td></tr>
<tr class="memdesc:a363ca18f6710cc1f4bcdb0f4f27aa197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise caches used in <a class="el" href="a00796.html" title="Class definition for applying n-qubit controlled unitary operations.">NCU</a> operation.  <a href="#a363ca18f6710cc1f4bcdb0f4f27aa197">More...</a><br /></td></tr>
<tr class="separator:a363ca18f6710cc1f4bcdb0f4f27aa197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09927c8826bba4cee6dca8de2202ba58"><td class="memTemplParams" colspan="2">template&lt;class Mat2x2Type &gt; </td></tr>
<tr class="memitem:a09927c8826bba4cee6dca8de2202ba58"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00932.html#a09927c8826bba4cee6dca8de2202ba58">addUToCache</a> (std::string gateLabel, const Mat2x2Type &amp;U)</td></tr>
<tr class="memdesc:a09927c8826bba4cee6dca8de2202ba58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a matrix to the cache, assigning it to a defined label. This is used in the caching for the <a class="el" href="a00796.html" title="Class definition for applying n-qubit controlled unitary operations.">NCU</a> operation.  <a href="#a09927c8826bba4cee6dca8de2202ba58">More...</a><br /></td></tr>
<tr class="separator:a09927c8826bba4cee6dca8de2202ba58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f644b1df965c72b3b06af4d9ff4d55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#a04f644b1df965c72b3b06af4d9ff4d55">PrintStates</a> (std::string x, std::vector&lt; std::size_t &gt; qubits={})</td></tr>
<tr class="memdesc:a04f644b1df965c72b3b06af4d9ff4d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the string x and then for each state of the specified qubits in the superposition, prints each its amplitude, followed by state and then by the probability of that state. Note that this state observation method is not a permitted quantum operation, however it is provided for convenience and debugging/testing.  <a href="#a04f644b1df965c72b3b06af4d9ff4d55">More...</a><br /></td></tr>
<tr class="separator:a04f644b1df965c72b3b06af4d9ff4d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbbba66d5941954ed70b9edc0e5174d"><td class="memTemplParams" colspan="2">template&lt;class Mat2x2Type &gt; </td></tr>
<tr class="memitem:acdbbba66d5941954ed70b9edc0e5174d"><td class="memTemplItemLeft" align="right" valign="top">Mat2x2Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00932.html#acdbbba66d5941954ed70b9edc0e5174d">matrixSqrt</a> (const Mat2x2Type &amp;U)</td></tr>
<tr class="memdesc:acdbbba66d5941954ed70b9edc0e5174d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the unitary matrix square root (U == VV, where V is returned)  <a href="#acdbbba66d5941954ed70b9edc0e5174d">More...</a><br /></td></tr>
<tr class="separator:acdbbba66d5941954ed70b9edc0e5174d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50f41419d061cef652876033aa7844c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#ae50f41419d061cef652876033aa7844c">InvertRegister</a> (const unsigned int minIdx, const unsigned int maxIdx)</td></tr>
<tr class="memdesc:ae50f41419d061cef652876033aa7844c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the register about the given indides: 0,1,2...n-1,n -&gt; n,n-1,...,1,0.  <a href="#ae50f41419d061cef652876033aa7844c">More...</a><br /></td></tr>
<tr class="separator:ae50f41419d061cef652876033aa7844c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:affe4a501359451bab21a62ce9763fa1d"><td class="memTemplParams" colspan="2">template&lt;class Mat2x2Type &gt; </td></tr>
<tr class="memitem:affe4a501359451bab21a62ce9763fa1d"><td class="memTemplItemLeft" align="right" valign="top">static Mat2x2Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00932.html#affe4a501359451bab21a62ce9763fa1d">adjointMatrix</a> (const Mat2x2Type &amp;U)</td></tr>
<tr class="memdesc:affe4a501359451bab21a62ce9763fa1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate the adjoint of an input matrix.  <a href="#affe4a501359451bab21a62ce9763fa1d">More...</a><br /></td></tr>
<tr class="separator:affe4a501359451bab21a62ce9763fa1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab74189d7b20e6932fd6d35a6153bf063"><td class="memItemLeft" align="right" valign="top">std::any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#ab74189d7b20e6932fd6d35a6153bf063">sim_ncu</a></td></tr>
<tr class="separator:ab74189d7b20e6932fd6d35a6153bf063"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aa967b57cdf4bbc98dde147db440c8c58"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#aa967b57cdf4bbc98dde147db440c8c58">SimulatorGeneral</a> ()</td></tr>
<tr class="memdesc:aa967b57cdf4bbc98dde147db440c8c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new Simulator General object.  <a href="#aa967b57cdf4bbc98dde147db440c8c58">More...</a><br /></td></tr>
<tr class="separator:aa967b57cdf4bbc98dde147db440c8c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:af4f1b3355061a1e13fffebb71176b353"><td class="memItemLeft" align="right" valign="top">friend&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a></td></tr>
<tr class="separator:af4f1b3355061a1e13fffebb71176b353"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class DerivedType&gt;<br />
class QNLP::SimulatorGeneral&lt; DerivedType &gt;</h3>

<p>CRTP defined class for simulator implementations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedType</td><td>CRTP derived class simulator type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00069">69</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa967b57cdf4bbc98dde147db440c8c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa967b57cdf4bbc98dde147db440c8c58">&#9670;&nbsp;</a></span>SimulatorGeneral()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::<a class="el" href="a00932.html">SimulatorGeneral</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new Simulator General object. </p>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00077">77</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;                      { </div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="comment">//If we are building MPI support, ensure that it is init&#39;d here before subclasses.</span></div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="preprocessor">    #ifdef ENABLE_MPI</span></div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        <span class="keywordtype">int</span> mpi_is_init;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        MPI_Initialized(&amp;mpi_is_init);</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        <span class="keywordflow">if</span> (! mpi_is_init){</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;            <span class="keywordtype">int</span> argc_tmp = 0;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;            <span class="keywordtype">char</span>** argv_tmp = <span class="keyword">new</span> <span class="keywordtype">char</span>*[argc_tmp];</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;            MPI_Init(&amp;argc_tmp, &amp;argv_tmp);</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;            <span class="keyword">delete</span> argv_tmp;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        }</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;<span class="preprocessor">    #endif</span></div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        <a class="code" href="a00932.html#ab74189d7b20e6932fd6d35a6153bf063">sim_ncu</a> =  NCU&lt;DerivedType&gt;(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>));</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    }; </div><div class="ttc" id="a00932_html_ab74189d7b20e6932fd6d35a6153bf063"><div class="ttname"><a href="a00932.html#ab74189d7b20e6932fd6d35a6153bf063">QNLP::SimulatorGeneral::sim_ncu</a></div><div class="ttdeci">std::any sim_ncu</div><div class="ttdef"><b>Definition:</b> <a href="a00173_source.html#l00104">Simulator.hpp:104</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6f0890bf195c53a3a9153f0eb25b6486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0890bf195c53a3a9153f0eb25b6486">&#9670;&nbsp;</a></span>~SimulatorGeneral()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::~<a class="el" href="a00932.html">SimulatorGeneral</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the Simulator General object. </p>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00113">113</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;{ }</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a09927c8826bba4cee6dca8de2202ba58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09927c8826bba4cee6dca8de2202ba58">&#9670;&nbsp;</a></span>addUToCache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<div class="memtemplate">
template&lt;class Mat2x2Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::addUToCache </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>gateLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat2x2Type &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a matrix to the cache, assigning it to a defined label. This is used in the caching for the <a class="el" href="a00796.html" title="Class definition for applying n-qubit controlled unitary operations.">NCU</a> operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mat2x2Type</td><td>Matrix type to be cached </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gateLabel</td><td>Label assigned to the matrix being cached </td></tr>
    <tr><td class="paramname">U</td><td>Matrix to be cached </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00703">703</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;                                                                  {</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;<span class="preprocessor">            #if defined(__INTEL_COMPILER) || defined(__INTEL_LLVM_COMPILER)</span></div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;            std::experimental::any_cast&lt;NCU&lt;DerivedType&gt;&amp;&gt;(<a class="code" href="a00932.html#ab74189d7b20e6932fd6d35a6153bf063">sim_ncu</a>).getGateCache().addToCache(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>), gateLabel, U, 16);</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;<span class="preprocessor">            #else</span></div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;            std::any_cast&lt;NCU&lt;DerivedType&gt;&amp;&gt;(<a class="code" href="a00932.html#ab74189d7b20e6932fd6d35a6153bf063">sim_ncu</a>).getGateCache().addToCache(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>), gateLabel, U, 16);</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;<span class="preprocessor">            #endif</span></div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;        }</div><div class="ttc" id="a00932_html_ab74189d7b20e6932fd6d35a6153bf063"><div class="ttname"><a href="a00932.html#ab74189d7b20e6932fd6d35a6153bf063">QNLP::SimulatorGeneral::sim_ncu</a></div><div class="ttdeci">std::any sim_ncu</div><div class="ttdef"><b>Definition:</b> <a href="a00173_source.html#l00104">Simulator.hpp:104</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="affe4a501359451bab21a62ce9763fa1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe4a501359451bab21a62ce9763fa1d">&#9670;&nbsp;</a></span>adjointMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<div class="memtemplate">
template&lt;class Mat2x2Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Mat2x2Type <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::adjointMatrix </td>
          <td>(</td>
          <td class="paramtype">const Mat2x2Type &amp;&#160;</td>
          <td class="paramname"><em>U</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to calculate the adjoint of an input matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mat2x2Type</td><td>Matrix type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>Unitary matrix to be adjointed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>openqu::TinyMatrix&lt;Type, 2, 2, 32&gt; U^{\dagger} </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00757">757</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;                                                            {</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;            Mat2x2Type Uadjoint(U);</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;            std::complex&lt;double&gt; <a class="code" href="a00214.html#af3f71bc96324526008d68c6581e8ace3">tmp</a>;</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;            <a class="code" href="a00214.html#af3f71bc96324526008d68c6581e8ace3">tmp</a> = Uadjoint(0,1);</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;            Uadjoint(0,1) = Uadjoint(1,0);</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;            Uadjoint(1,0) = <a class="code" href="a00214.html#af3f71bc96324526008d68c6581e8ace3">tmp</a>;</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;            Uadjoint(0,0) = std::conj(Uadjoint(0,0));</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;            Uadjoint(0,1) = std::conj(Uadjoint(0,1));</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;            Uadjoint(1,0) = std::conj(Uadjoint(1,0));</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;            Uadjoint(1,1) = std::conj(Uadjoint(1,1));</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;            <span class="keywordflow">return</span> Uadjoint;</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;        }</div><div class="ttc" id="a00214_html_af3f71bc96324526008d68c6581e8ace3"><div class="ttname"><a href="a00214.html#af3f71bc96324526008d68c6581e8ace3">QNLP.tagging.tag_file.tmp</a></div><div class="ttdeci">tmp</div><div class="ttdef"><b>Definition:</b> <a href="a00122_source.html#l00087">tag_file.py:87</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4cfa1a862e7bb752f703f0c4234959f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cfa1a862e7bb752f703f0c4234959f1">&#9670;&nbsp;</a></span>applyDiffusion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyDiffusion </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctrlIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply diffusion operator on marked state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlIndices</td><td>Vector of control line indices </td></tr>
    <tr><td class="paramname">target</td><td>Target qubit index to apply Ctrl-Z upon. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00536">536</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;                                                                                      {</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;            Diffusion&lt;DerivedType&gt; diffusion;</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;            diffusion.applyOpDiffusion(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>), ctrlIndices, <a class="code" href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">target</a>);</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;        }</div><div class="ttc" id="a00221_html_a04d504e3a1d9b0157c4d2d1de832d0ed"><div class="ttname"><a href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">ncu_opt_tester.target</a></div><div class="ttdeci">int target</div><div class="ttdef"><b>Definition:</b> <a href="a00143_source.html#l00011">ncu_opt_tester.py:11</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa09d709544b5fe78942622e7f567399a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09d709544b5fe78942622e7f567399a">&#9670;&nbsp;</a></span>applyGateCCX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateCCX </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>ctrl_qubit0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>ctrl_qubit1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>target_qubit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Controlled controlled NOT (CCNOT, CCX) gate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrl_qubit0</td><td>Control qubit 0 </td></tr>
    <tr><td class="paramname">ctrl_qubit1</td><td>Control qubit 1 </td></tr>
    <tr><td class="paramname">target_qubit</td><td>Target qubit </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00346">346</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;                                                                                               {</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;            static_cast&lt;DerivedType*&gt;(<span class="keyword">this</span>)-&gt;applyGateCCX(ctrl_qubit0, ctrl_qubit1, target_qubit);</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="aec4363d9df7109c2d57b15746507ecf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4363d9df7109c2d57b15746507ecf5">&#9670;&nbsp;</a></span>applyGateCH()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateCH </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply Controlled Hadamard on target qubit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">control</td><td>Qubit index acting as control </td></tr>
    <tr><td class="paramname">target</td><td>Qubit index acting as target </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00294">294</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;                                                                         {</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;            static_cast&lt;DerivedType*&gt;(<span class="keyword">this</span>)-&gt;applyGateCH(control, <a class="code" href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">target</a>);</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;        }</div><div class="ttc" id="a00221_html_a04d504e3a1d9b0157c4d2d1de832d0ed"><div class="ttname"><a href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">ncu_opt_tester.target</a></div><div class="ttdeci">int target</div><div class="ttdef"><b>Definition:</b> <a href="a00143_source.html#l00011">ncu_opt_tester.py:11</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0e3479e8edbd4bb56b68d27a57057b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3479e8edbd4bb56b68d27a57057b9e">&#9670;&nbsp;</a></span>applyGateCPhaseShift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateCPhaseShift </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform controlled phase shift gate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>Angle of phase shift in rads </td></tr>
    <tr><td class="paramname">control</td><td>Index of control qubit </td></tr>
    <tr><td class="paramname">target</td><td>Index of target qubit </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00335">335</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                                                                                    {</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;            static_cast&lt;DerivedType*&gt;(<span class="keyword">this</span>)-&gt;applyGateCPhaseShift(angle, control, <a class="code" href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">target</a>);</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        }</div><div class="ttc" id="a00221_html_a04d504e3a1d9b0157c4d2d1de832d0ed"><div class="ttname"><a href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">ncu_opt_tester.target</a></div><div class="ttdeci">int target</div><div class="ttdef"><b>Definition:</b> <a href="a00143_source.html#l00011">ncu_opt_tester.py:11</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3ec7eac350b2da8a2b0bcb05e4cd8a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec7eac350b2da8a2b0bcb05e4cd8a3f">&#9670;&nbsp;</a></span>applyGateCRotX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateCRotX </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>ctrl_qubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>qubit_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_rad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the given Controlled Rotation about X-axis to the given qubit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrl_qubit</td><td>Control qubit </td></tr>
    <tr><td class="paramname">qubit_idx</td><td>Index of qubit to rotate about X-axis </td></tr>
    <tr><td class="paramname">angle_rad</td><td>Rotation angle </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00373">373</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;                                                                                        {</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;            static_cast&lt;DerivedType&amp;&gt;(*this).applyGateCRotX(ctrl_qubit, qubit_idx, angle_rad);</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="a31b08ec373fc8b181cf9d628483f11a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b08ec373fc8b181cf9d628483f11a0">&#9670;&nbsp;</a></span>applyGateCRotY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateCRotY </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>ctrl_qubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>qubit_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_rad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the given Controlled Rotation about Y-axis to the given qubit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrl_qubit</td><td>Control qubit </td></tr>
    <tr><td class="paramname">qubit_idx</td><td>Index of qubit to rotate about Y-axis </td></tr>
    <tr><td class="paramname">angle_rad</td><td>Rotation angle </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00384">384</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;                                                                                        {</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;            static_cast&lt;DerivedType&amp;&gt;(*this).applyGateCRotY(ctrl_qubit, qubit_idx, angle_rad);</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="a2b519b081690689fbf838d5680d2a007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b519b081690689fbf838d5680d2a007">&#9670;&nbsp;</a></span>applyGateCRotZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateCRotZ </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>ctrl_qubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>qubit_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_rad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the given Controlled Rotation about Z-axis to the given qubit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrl_qubit</td><td>Control qubit </td></tr>
    <tr><td class="paramname">qubit_idx</td><td>Index of qubit to rotate about Z-axis </td></tr>
    <tr><td class="paramname">angle_rad</td><td>Rotation angle </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00395">395</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;                                                                                        {</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;            static_cast&lt;DerivedType&amp;&gt;(*this).applyGateCRotZ(ctrl_qubit, qubit_idx, angle_rad);</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="ac3c00b65cc011c4a6bf0478e9d4a7edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c00b65cc011c4a6bf0478e9d4a7edf">&#9670;&nbsp;</a></span>applyGateCSwap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateCSwap </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>ctrl_qubit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>qubit_swap0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>qubit_swap1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Controlled SWAP gate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrl_qubit</td><td>Control qubit </td></tr>
    <tr><td class="paramname">qubit_swap0</td><td>Swap qubit 0 </td></tr>
    <tr><td class="paramname">qubit_swap1</td><td>Swap qubit 1 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00357">357</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;                                                                                               {</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;            assert( static_cast&lt;DerivedType*&gt;(<span class="keyword">this</span>)-&gt;<a class="code" href="a00932.html#a106178245fff70419c4de79b26592ba3">getNumQubits</a>() &gt; 2 );</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;            <span class="comment">//The requested qubit indices must be available to use within the register range</span></div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;            assert( (ctrl_qubit &lt; <a class="code" href="a00932.html#a106178245fff70419c4de79b26592ba3">getNumQubits</a>() ) &amp;&amp; (qubit_swap0 &lt; <a class="code" href="a00932.html#a106178245fff70419c4de79b26592ba3">getNumQubits</a>() ) &amp;&amp; (qubit_swap1 &lt; <a class="code" href="a00932.html#a106178245fff70419c4de79b26592ba3">getNumQubits</a>()) );</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;            <span class="comment">//The qubits must be different from one another</span></div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;            assert( ctrl_qubit != qubit_swap0 &amp;&amp; ctrl_qubit != qubit_swap1 &amp;&amp; qubit_swap0 != qubit_swap1 );</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;            static_cast&lt;DerivedType*&gt;(<span class="keyword">this</span>)-&gt;applyGateCSwap(ctrl_qubit, qubit_swap0, qubit_swap1);</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;        }</div><div class="ttc" id="a00932_html_a106178245fff70419c4de79b26592ba3"><div class="ttname"><a href="a00932.html#a106178245fff70419c4de79b26592ba3">QNLP::SimulatorGeneral::getNumQubits</a></div><div class="ttdeci">std::size_t getNumQubits()</div><div class="ttdoc">Get the number of Qubits.</div><div class="ttdef"><b>Definition:</b> <a href="a00173_source.html#l00413">Simulator.hpp:413</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a78d536516bf3a71c776d97e974347d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d536516bf3a71c776d97e974347d43">&#9670;&nbsp;</a></span>applyGateCU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<div class="memtemplate">
template&lt;class Mat2x2Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateCU </td>
          <td>(</td>
          <td class="paramtype">const Mat2x2Type &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>label</em> = <code>&quot;CU&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the given controlled unitary gate on target qubit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>User-defined arbitrary 2x2 unitary gate (matrix) </td></tr>
    <tr><td class="paramname">control</td><td>Qubit index acting as control </td></tr>
    <tr><td class="paramname">target</td><td>Qubit index acting as target </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00254">254</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;                                                                                                                    {</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;            static_cast&lt;DerivedType*&gt;(<span class="keyword">this</span>)-&gt;applyGateCU(U, control, <a class="code" href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">target</a>, label);</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;        }</div><div class="ttc" id="a00221_html_a04d504e3a1d9b0157c4d2d1de832d0ed"><div class="ttname"><a href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">ncu_opt_tester.target</a></div><div class="ttdeci">int target</div><div class="ttdef"><b>Definition:</b> <a href="a00143_source.html#l00011">ncu_opt_tester.py:11</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a21bc894a2c0b0fd29bcbf8182ba27a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21bc894a2c0b0fd29bcbf8182ba27a3b">&#9670;&nbsp;</a></span>applyGateCX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateCX </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply Controlled Pauli-X (CNOT) on target qubit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">control</td><td>Qubit index acting as control </td></tr>
    <tr><td class="paramname">target</td><td>Qubit index acting as target </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00264">264</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;                                                                         {</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;            static_cast&lt;DerivedType*&gt;(<span class="keyword">this</span>)-&gt;applyGateCX(control, <a class="code" href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">target</a>);</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;        }</div><div class="ttc" id="a00221_html_a04d504e3a1d9b0157c4d2d1de832d0ed"><div class="ttname"><a href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">ncu_opt_tester.target</a></div><div class="ttdeci">int target</div><div class="ttdef"><b>Definition:</b> <a href="a00143_source.html#l00011">ncu_opt_tester.py:11</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af06d08514aca47c3c4f29ba5d450feb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06d08514aca47c3c4f29ba5d450feb6">&#9670;&nbsp;</a></span>applyGateCY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateCY </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply Controlled Pauli-Y on target qubit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">control</td><td>Qubit index acting as control </td></tr>
    <tr><td class="paramname">target</td><td>Qubit index acting as target </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00274">274</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;                                                                         {</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;            static_cast&lt;DerivedType*&gt;(<span class="keyword">this</span>)-&gt;applyGateCY(control, <a class="code" href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">target</a>);</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;        }</div><div class="ttc" id="a00221_html_a04d504e3a1d9b0157c4d2d1de832d0ed"><div class="ttname"><a href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">ncu_opt_tester.target</a></div><div class="ttdeci">int target</div><div class="ttdef"><b>Definition:</b> <a href="a00143_source.html#l00011">ncu_opt_tester.py:11</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af43f726f5d65edc5d074306bc9f6d27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43f726f5d65edc5d074306bc9f6d27a">&#9670;&nbsp;</a></span>applyGateCZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateCZ </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply Controlled Pauli-Z on target qubit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">control</td><td>Qubit index acting as control </td></tr>
    <tr><td class="paramname">target</td><td>Qubit index acting as target </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00284">284</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;                                                                         {</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;            static_cast&lt;DerivedType*&gt;(<span class="keyword">this</span>)-&gt;applyGateCZ(control, <a class="code" href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">target</a>);</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;        }</div><div class="ttc" id="a00221_html_a04d504e3a1d9b0157c4d2d1de832d0ed"><div class="ttname"><a href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">ncu_opt_tester.target</a></div><div class="ttdeci">int target</div><div class="ttdef"><b>Definition:</b> <a href="a00143_source.html#l00011">ncu_opt_tester.py:11</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ada1bd53ebb7b9be3ee37ff1a5700d3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1bd53ebb7b9be3ee37ff1a5700d3ac">&#9670;&nbsp;</a></span>applyGateH()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateH </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>qubit_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the Hadamard gate to the given qubit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubit_idx</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00155">155</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;                                            {</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;            static_cast&lt;DerivedType&amp;&gt;(*this).applyGateH(qubit_idx);</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="a35375a9e4e73e0fe1073cf833a33fda4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35375a9e4e73e0fe1073cf833a33fda4">&#9670;&nbsp;</a></span>applyGateI()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateI </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>qubit_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the Identity gate to the given qubit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubit_idx</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00147">147</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;                                            {</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;            static_cast&lt;DerivedType&amp;&gt;(*this).applyGateI(qubit_idx); </div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="a913db3f649fd704afcf75f4f8e9789de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913db3f649fd704afcf75f4f8e9789de">&#9670;&nbsp;</a></span>applyGateNCU() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<div class="memtemplate">
template&lt;class Mat2x2Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateNCU </td>
          <td>(</td>
          <td class="paramtype">const Mat2x2Type &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctrlIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply n-control unitary gate to the given qubit target. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mat2x2Type</td><td>2x2 Matrix type of unitary gate in the format expected by the derived simulator object; decltype(simulator.getGateX()) can be used in template </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>2x2 unitary matrix </td></tr>
    <tr><td class="paramname">ctrlIndices</td><td>Vector of the control lines for <a class="el" href="a00796.html" title="Class definition for applying n-qubit controlled unitary operations.">NCU</a> operation </td></tr>
    <tr><td class="paramname">target</td><td>Target qubit index to apply nCU </td></tr>
    <tr><td class="paramname">label</td><td>Gate label string (U, X, Y, etc.) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00462">462</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;                                                                                                                          {</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;<span class="preprocessor">            #if defined(__INTEL_COMPILER) || defined(__INTEL_LLVM_COMPILER)</span></div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;            std::experimental::any_cast&lt;NCU&lt;DerivedType&gt;&amp;&gt;(<a class="code" href="a00932.html#ab74189d7b20e6932fd6d35a6153bf063">sim_ncu</a>).applyNQubitControl(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>), ctrlIndices, {}, <a class="code" href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">target</a>, label, U, 0);</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;<span class="preprocessor">            #else</span></div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;            std::any_cast&lt;NCU&lt;DerivedType&gt;&amp;&gt;(<a class="code" href="a00932.html#ab74189d7b20e6932fd6d35a6153bf063">sim_ncu</a>).applyNQubitControl(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>), ctrlIndices, {}, <a class="code" href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">target</a>, label, U, 0);</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;<span class="preprocessor">            #endif</span></div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;        }</div><div class="ttc" id="a00932_html_ab74189d7b20e6932fd6d35a6153bf063"><div class="ttname"><a href="a00932.html#ab74189d7b20e6932fd6d35a6153bf063">QNLP::SimulatorGeneral::sim_ncu</a></div><div class="ttdeci">std::any sim_ncu</div><div class="ttdef"><b>Definition:</b> <a href="a00173_source.html#l00104">Simulator.hpp:104</a></div></div>
<div class="ttc" id="a00221_html_a04d504e3a1d9b0157c4d2d1de832d0ed"><div class="ttname"><a href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">ncu_opt_tester.target</a></div><div class="ttdeci">int target</div><div class="ttdef"><b>Definition:</b> <a href="a00143_source.html#l00011">ncu_opt_tester.py:11</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac1b264c7e265e918011016acfcff1b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b264c7e265e918011016acfcff1b70">&#9670;&nbsp;</a></span>applyGateNCU() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<div class="memtemplate">
template&lt;class Mat2x2Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateNCU </td>
          <td>(</td>
          <td class="paramtype">const Mat2x2Type &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctrlIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>auxIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply n-control sigma_x gate to the given qubit target, using auxiliary qubits for 5CX optimisation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mat2x2Type</td><td>2x2 Matrix type of unitary gate in the format expected by the derived simulator object; decltype(simulator.getGateX()) can be used in template </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>2x2 unitary matrix </td></tr>
    <tr><td class="paramname">minIdx</td><td>Lowest index of the control lines expected for nCU </td></tr>
    <tr><td class="paramname">maxIdx</td><td>Highest index of the control lines expected for the nCU </td></tr>
    <tr><td class="paramname">target</td><td>Target qubit index to apply nCU </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00480">480</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;                                                                                                                                                                  {</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;<span class="preprocessor">            #if defined(__INTEL_COMPILER) || defined(__INTEL_LLVM_COMPILER)</span></div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;            std::experimental::any_cast&lt;NCU&lt;DerivedType&gt;&amp;&gt;(<a class="code" href="a00932.html#ab74189d7b20e6932fd6d35a6153bf063">sim_ncu</a>).applyNQubitControl(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>), ctrlIndices, auxIndices, <a class="code" href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">target</a>, label, U, 0);</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;<span class="preprocessor">            #else</span></div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;            std::any_cast&lt;NCU&lt;DerivedType&gt;&amp;&gt;(<a class="code" href="a00932.html#ab74189d7b20e6932fd6d35a6153bf063">sim_ncu</a>).applyNQubitControl(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>), ctrlIndices, auxIndices, <a class="code" href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">target</a>, label, U, 0);</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;<span class="preprocessor">            #endif</span></div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;        }</div><div class="ttc" id="a00932_html_ab74189d7b20e6932fd6d35a6153bf063"><div class="ttname"><a href="a00932.html#ab74189d7b20e6932fd6d35a6153bf063">QNLP::SimulatorGeneral::sim_ncu</a></div><div class="ttdeci">std::any sim_ncu</div><div class="ttdef"><b>Definition:</b> <a href="a00173_source.html#l00104">Simulator.hpp:104</a></div></div>
<div class="ttc" id="a00221_html_a04d504e3a1d9b0157c4d2d1de832d0ed"><div class="ttname"><a href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">ncu_opt_tester.target</a></div><div class="ttdeci">int target</div><div class="ttdef"><b>Definition:</b> <a href="a00143_source.html#l00011">ncu_opt_tester.py:11</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a365ed045daa5b15b3ebc71afe29e35b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365ed045daa5b15b3ebc71afe29e35b8">&#9670;&nbsp;</a></span>applyGatePhaseShift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGatePhaseShift </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>qubit_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply phase shift to given Qubit; [[1 0] [0 exp(i*angle)]]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>Angle of phase shift in rads </td></tr>
    <tr><td class="paramname">qubit_idx</td><td>Qubit index to perform phase shift upon </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00324">324</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;                                                                   {</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;            static_cast&lt;DerivedType*&gt;(<span class="keyword">this</span>)-&gt;applyGatePhaseShift(angle, qubit_idx);</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="a8e45ecfec7bf9da83750f7a3a671dd9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e45ecfec7bf9da83750f7a3a671dd9d">&#9670;&nbsp;</a></span>applyGateRotX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateRotX </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>qubit_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_rad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the given Rotation about X-axis to the given qubit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubit_idx</td><td>Index of qubit to rotate about X-axis </td></tr>
    <tr><td class="paramname">angle_rad</td><td>Rotation angle </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00172">172</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                                                                 {</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;            static_cast&lt;DerivedType&amp;&gt;(*this).applyGateRotX(qubit_idx, angle_rad);</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="abbdf0e4f4d0cdad91178e44336963fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdf0e4f4d0cdad91178e44336963fa7">&#9670;&nbsp;</a></span>applyGateRotY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateRotY </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>qubit_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_rad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the given Rotation about Y-axis to the given qubit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubit_idx</td><td>Index of qubit to rotate about Y-axis </td></tr>
    <tr><td class="paramname">angle_rad</td><td>Rotation angle </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00181">181</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                                                                 {</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;            static_cast&lt;DerivedType&amp;&gt;(*this).applyGateRotY(qubit_idx, angle_rad);</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="ad6b45faaf1e972ea9f3501e040014a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b45faaf1e972ea9f3501e040014a55">&#9670;&nbsp;</a></span>applyGateRotZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateRotZ </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>qubit_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_rad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the given Rotation about Z-axis to the given qubit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubit_idx</td><td>Index of qubit to rotate about Z-axis </td></tr>
    <tr><td class="paramname">angle_rad</td><td>Rotation angle </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00190">190</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;                                                                 {</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;            static_cast&lt;DerivedType&amp;&gt;(*this).applyGateRotZ(qubit_idx, angle_rad);</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="a98a5b3cf59b4138390aa6ed9b5bc8091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a5b3cf59b4138390aa6ed9b5bc8091">&#9670;&nbsp;</a></span>applyGateSqrtSwap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateSqrtSwap </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>qubit_idx0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>qubit_idx1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs Sqrt SWAP gate between two given qubits (half way SWAP) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubit_idx0</td><td>Qubit index 0 </td></tr>
    <tr><td class="paramname">qubit_idx1</td><td>Qubit index 1 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00314">314</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                                                                          {</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;            static_cast&lt;DerivedType*&gt;(<span class="keyword">this</span>)-&gt;applyGateSqrtSwap(qubit_idx0,qubit_idx1);</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="aa82e3157659365e42adeb1086c15050f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82e3157659365e42adeb1086c15050f">&#9670;&nbsp;</a></span>applyGateSqrtX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateSqrtX </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>qubit_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the Sqrt{Pauli X} gate to the given qubit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubit_idx</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00163">163</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;                                                {</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;            static_cast&lt;DerivedType&amp;&gt;(*this).applyGateSqrtX(qubit_idx);</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="ab5d968b4660a5a095825c8139abc5bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d968b4660a5a095825c8139abc5bdd">&#9670;&nbsp;</a></span>applyGateSwap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateSwap </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>qubit_idx0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>qubit_idx1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the qubits at the given indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubit_idx0</td><td>Index of qubit 0 to swap &amp;(0 -&gt; 1) </td></tr>
    <tr><td class="paramname">qubit_idx1</td><td>Index of qubit 1 to swap &amp;(1 -&gt; 0) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00304">304</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                                                                      {</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;            static_cast&lt;DerivedType*&gt;(<span class="keyword">this</span>)-&gt;applyGateSwap(qubit_idx0,qubit_idx1);</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        }</div></div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="a00173_source.html#l00776">QNLP::SimulatorGeneral&lt; IntelSimulator &gt;::InvertRegister()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="a00932_ab5d968b4660a5a095825c8139abc5bdd_icgraph.png" border="0" usemap="#a00932_ab5d968b4660a5a095825c8139abc5bdd_icgraph" alt=""/></div>
<map name="a00932_ab5d968b4660a5a095825c8139abc5bdd_icgraph" id="a00932_ab5d968b4660a5a095825c8139abc5bdd_icgraph">
<area shape="rect"  title="Swap the qubits at the given indices." alt="" coords="271,5,440,47"/>
<area shape="rect"  href="a00932.html#ae50f41419d061cef652876033aa7844c" title="Invert the register about the given indides: 0,1,2...n&#45;1,n &#45;&gt; n,n&#45;1,...,1,0." alt="" coords="5,5,223,47"/>
</map>
</div>

</div>
</div>
<a id="ad11efa58599dc066c15e376465649c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11efa58599dc066c15e376465649c4e">&#9670;&nbsp;</a></span>applyGateU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<div class="memtemplate">
template&lt;class Mat2x2Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateU </td>
          <td>(</td>
          <td class="paramtype">const Mat2x2Type &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>qubit_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply arbitrary user-defined unitary gate to qubit at qubit_idx. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>User-defined unitary 2x2 matrix of templated type Mat2x2Type </td></tr>
    <tr><td class="paramname">qubit_idx</td><td>Index of qubit to apply gate upon </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00201">201</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;                                                                 {</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;            static_cast&lt;DerivedType*&gt;(<span class="keyword">this</span>)-&gt;applyGateU(U, qubit_idx);</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="ac4359d766497887ac5a48a1d245a1213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4359d766497887ac5a48a1d245a1213">&#9670;&nbsp;</a></span>applyGateX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateX </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>qubit_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the Pauli X gate to the given qubit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubit_idx</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00123">123</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;                                            { </div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;            static_cast&lt;DerivedType&amp;&gt;(*this).applyGateX(qubit_idx);</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        };</div></div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="a00173_source.html#l00548">QNLP::SimulatorGeneral&lt; IntelSimulator &gt;::encodeToRegister()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="a00932_ac4359d766497887ac5a48a1d245a1213_icgraph.png" border="0" usemap="#a00932_ac4359d766497887ac5a48a1d245a1213_icgraph" alt=""/></div>
<map name="a00932_ac4359d766497887ac5a48a1d245a1213_icgraph" id="a00932_ac4359d766497887ac5a48a1d245a1213_icgraph">
<area shape="rect"  title="Apply the Pauli X gate to the given qubit." alt="" coords="247,13,416,54"/>
<area shape="rect"  href="a00932.html#a2cc0205185d34a8756670fa138666b5e" title="Encodes a defined binary pattern into a defined target register (initially in state |00...." alt="" coords="5,5,199,61"/>
</map>
</div>

</div>
</div>
<a id="afaee0fc26c962053d4279b6df07a94b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaee0fc26c962053d4279b6df07a94b2">&#9670;&nbsp;</a></span>applyGateY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateY </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>qubit_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the Pauli Y gate to the given qubit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubit_idx</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00131">131</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;                                            {</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;            static_cast&lt;DerivedType&amp;&gt;(*this).applyGateY(qubit_idx);</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="af5201daf966d9261c6c18939d8f70338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5201daf966d9261c6c18939d8f70338">&#9670;&nbsp;</a></span>applyGateZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyGateZ </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>qubit_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the Pauli Z gate to the given qubit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qubit_idx</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00139">139</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;                                            {</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;            static_cast&lt;DerivedType&amp;&gt;(*this).applyGateZ(qubit_idx);</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="a62363e702fcea7868324c69a076d60ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62363e702fcea7868324c69a076d60ea">&#9670;&nbsp;</a></span>applyHammingDistanceOverwrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyHammingDistanceOverwrite </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>test_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>reg_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>reg_auxiliary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_bin_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the relative Hamming distance between the test pattern and the pattern stored in each state of the superposition, overwriting the aux register pattern with the resulting bit differences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test_pattern</td><td><a class="el" href="a00952.html">The</a> binary pattern used as the the basis for the Hamming Distance. </td></tr>
    <tr><td class="paramname">reg_mem</td><td>Vector containing the indices of the register qubits that contain the training patterns. </td></tr>
    <tr><td class="paramname">reg_auxiliary</td><td>Vector containing the indices of the register qubits which the first len_bin_pattern qubits will store the test_pattern. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00609">609</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;                                          {</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;            assert(reg_mem.size() &lt; <a class="code" href="a00222.html#a98e4f565503604c2b25fb9f4a98c83af">reg_auxiliary</a>.size()-1);</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;            <span class="comment">// Encode test pattern to auxiliary register</span></div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;            <a class="code" href="a00932.html#a2cc0205185d34a8756670fa138666b5e">encodeToRegister</a>(<a class="code" href="a00222.html#a67583c588c08d739854caef7dc2f724a">test_pattern</a>, <a class="code" href="a00222.html#a98e4f565503604c2b25fb9f4a98c83af">reg_auxiliary</a>, len_bin_pattern);</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;            <a class="code" href="a00812.html#a5e9e3661eaaeb0b049cc18e879221b91">HammingDistance&lt;DerivedType&gt;::computeHammingDistanceOverwriteAux</a>(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>), reg_mem, <a class="code" href="a00222.html#a98e4f565503604c2b25fb9f4a98c83af">reg_auxiliary</a>);</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;        }</div><div class="ttc" id="a00932_html_a2cc0205185d34a8756670fa138666b5e"><div class="ttname"><a href="a00932.html#a2cc0205185d34a8756670fa138666b5e">QNLP::SimulatorGeneral::encodeToRegister</a></div><div class="ttdeci">void encodeToRegister(std::size_t target_pattern, const std::vector&lt; std::size_t &gt; target_register, std::size_t len_bin_pattern)</div><div class="ttdoc">Encodes a defined binary pattern into a defined target register (initially in state |00....</div><div class="ttdef"><b>Definition:</b> <a href="a00173_source.html#l00548">Simulator.hpp:548</a></div></div>
<div class="ttc" id="a00812_html_a5e9e3661eaaeb0b049cc18e879221b91"><div class="ttname"><a href="a00812.html#a5e9e3661eaaeb0b049cc18e879221b91">QNLP::HammingDistance::computeHammingDistanceOverwriteAux</a></div><div class="ttdeci">static void computeHammingDistanceOverwriteAux(SimulatorType &amp;qSim, const std::vector&lt; std::size_t &gt; &amp;reg_memory, const std::vector&lt; std::size_t &gt; &amp;reg_auxiliary)</div><div class="ttdoc">Computes Hamming Distance; Overwrites the pattern in reg_auxiliary to track bit differences from reg_...</div><div class="ttdef"><b>Definition:</b> <a href="a00044_source.html#l00102">hamming.hpp:102</a></div></div>
<div class="ttc" id="a00222_html_a98e4f565503604c2b25fb9f4a98c83af"><div class="ttname"><a href="a00222.html#a98e4f565503604c2b25fb9f4a98c83af">QNLP_7qubit_pattern_example.reg_auxiliary</a></div><div class="ttdeci">list reg_auxiliary</div><div class="ttdef"><b>Definition:</b> <a href="a00146_source.html#l00040">QNLP_7qubit_pattern_example.py:40</a></div></div>
<div class="ttc" id="a00222_html_a67583c588c08d739854caef7dc2f724a"><div class="ttname"><a href="a00222.html#a67583c588c08d739854caef7dc2f724a">QNLP_7qubit_pattern_example.test_pattern</a></div><div class="ttdeci">int test_pattern</div><div class="ttdef"><b>Definition:</b> <a href="a00146_source.html#l00101">QNLP_7qubit_pattern_example.py:101</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a879f5f6c2a27305df3b5f0a8ab7552a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879f5f6c2a27305df3b5f0a8ab7552a9">&#9670;&nbsp;</a></span>applyHammingDistanceRotY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyHammingDistanceRotY </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>test_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>reg_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>reg_auxiliary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_bin_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the relative Hamming distance between the test pattern and the pattern stored in each state of the superposition, storing the result in the amplitude of the corresponding state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test_pattern</td><td><a class="el" href="a00952.html">The</a> binary pattern used as the the basis for the Hamming Distance. </td></tr>
    <tr><td class="paramname">reg_mem</td><td>Vector containing the indices of the register qubits that contain the training patterns. </td></tr>
    <tr><td class="paramname">reg_auxiliary</td><td>Vector containing the indices of the register qubits which the first len_bin_pattern qubits will store the test_pattern. </td></tr>
    <tr><td class="paramname">len_bin_pattern</td><td>Length of the binary patterns </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00584">584</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;                                          {</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;            assert(len_bin_pattern &lt; <a class="code" href="a00222.html#a98e4f565503604c2b25fb9f4a98c83af">reg_auxiliary</a>.size()-1);</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;            <span class="comment">// Encode test pattern to auxiliary register</span></div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;            <a class="code" href="a00932.html#a2cc0205185d34a8756670fa138666b5e">encodeToRegister</a>(<a class="code" href="a00222.html#a67583c588c08d739854caef7dc2f724a">test_pattern</a>, <a class="code" href="a00222.html#a98e4f565503604c2b25fb9f4a98c83af">reg_auxiliary</a>, len_bin_pattern);</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;            HammingDistance&lt;DerivedType&gt; hamming_operator(len_bin_pattern);</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;            hamming_operator.computeHammingDistanceRotY(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>), reg_mem, <a class="code" href="a00222.html#a98e4f565503604c2b25fb9f4a98c83af">reg_auxiliary</a>, len_bin_pattern);</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;            <span class="comment">// Un-encode test pattern from auxiliary register</span></div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;            <a class="code" href="a00932.html#a2cc0205185d34a8756670fa138666b5e">encodeToRegister</a>(<a class="code" href="a00222.html#a67583c588c08d739854caef7dc2f724a">test_pattern</a>, <a class="code" href="a00222.html#a98e4f565503604c2b25fb9f4a98c83af">reg_auxiliary</a>, len_bin_pattern);</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;        }</div><div class="ttc" id="a00932_html_a2cc0205185d34a8756670fa138666b5e"><div class="ttname"><a href="a00932.html#a2cc0205185d34a8756670fa138666b5e">QNLP::SimulatorGeneral::encodeToRegister</a></div><div class="ttdeci">void encodeToRegister(std::size_t target_pattern, const std::vector&lt; std::size_t &gt; target_register, std::size_t len_bin_pattern)</div><div class="ttdoc">Encodes a defined binary pattern into a defined target register (initially in state |00....</div><div class="ttdef"><b>Definition:</b> <a href="a00173_source.html#l00548">Simulator.hpp:548</a></div></div>
<div class="ttc" id="a00222_html_a98e4f565503604c2b25fb9f4a98c83af"><div class="ttname"><a href="a00222.html#a98e4f565503604c2b25fb9f4a98c83af">QNLP_7qubit_pattern_example.reg_auxiliary</a></div><div class="ttdeci">list reg_auxiliary</div><div class="ttdef"><b>Definition:</b> <a href="a00146_source.html#l00040">QNLP_7qubit_pattern_example.py:40</a></div></div>
<div class="ttc" id="a00222_html_a67583c588c08d739854caef7dc2f724a"><div class="ttname"><a href="a00222.html#a67583c588c08d739854caef7dc2f724a">QNLP_7qubit_pattern_example.test_pattern</a></div><div class="ttdeci">int test_pattern</div><div class="ttdef"><b>Definition:</b> <a href="a00146_source.html#l00101">QNLP_7qubit_pattern_example.py:101</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="addefd63a2c9fa6136bc8c289482fedf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addefd63a2c9fa6136bc8c289482fedf1">&#9670;&nbsp;</a></span>applyIQFT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyIQFT </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>minIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>maxIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the inverse Quantum Fourier transform (IQFT) to the given register index range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minIdx</td><td>Lowest qubit index of the IQFT range </td></tr>
    <tr><td class="paramname">maxIdx</td><td>Highest qubit index of the IQFT range </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00433">433</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;                                                          {</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;            QFT&lt;decltype(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>))&gt;::<a class="code" href="a00932.html#addefd63a2c9fa6136bc8c289482fedf1">applyIQFT</a>(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>), minIdx, maxIdx);</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;        }</div><div class="ttc" id="a00932_html_addefd63a2c9fa6136bc8c289482fedf1"><div class="ttname"><a href="a00932.html#addefd63a2c9fa6136bc8c289482fedf1">QNLP::SimulatorGeneral::applyIQFT</a></div><div class="ttdeci">void applyIQFT(std::size_t minIdx, std::size_t maxIdx)</div><div class="ttdoc">Apply the inverse Quantum Fourier transform (IQFT) to the given register index range.</div><div class="ttdef"><b>Definition:</b> <a href="a00173_source.html#l00433">Simulator.hpp:433</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="a00173_source.html#l00433">QNLP::SimulatorGeneral&lt; IntelSimulator &gt;::applyIQFT()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="a00932_addefd63a2c9fa6136bc8c289482fedf1_icgraph.png" border="0" usemap="#a00932_addefd63a2c9fa6136bc8c289482fedf1_icgraph" alt=""/></div>
<map name="a00932_addefd63a2c9fa6136bc8c289482fedf1_icgraph" id="a00932_addefd63a2c9fa6136bc8c289482fedf1_icgraph">
<area shape="rect"  title="Apply the inverse Quantum Fourier transform (IQFT) to the given register index range." alt="" coords="5,29,175,71"/>
</map>
</div>

</div>
</div>
<a id="a6e7e9960c3af1bbce94a8f68eb09ecf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7e9960c3af1bbce94a8f68eb09ecf2">&#9670;&nbsp;</a></span>applyMeasurement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyMeasurement </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply measurement to a target qubit, randomly collapsing the qubit proportional to the amplitude and returns the collapsed value. </p>
<dl class="section return"><dt>Returns</dt><dd>bool Value that qubit is randomly collapsed to </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td><a class="el" href="a00952.html">The</a> index of the qubit being collapsed </td></tr>
    <tr><td class="paramname">normalize</td><td>Optional argument specifying whether amplitudes shoud be normalized (true) or not (false). Default value is true. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00629">629</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;                                                                    {</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;            <span class="keywordflow">return</span> static_cast&lt;DerivedType*&gt;(<span class="keyword">this</span>)-&gt;applyMeasurement(<a class="code" href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">target</a>, normalize);</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;        }</div><div class="ttc" id="a00221_html_a04d504e3a1d9b0157c4d2d1de832d0ed"><div class="ttname"><a href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">ncu_opt_tester.target</a></div><div class="ttdeci">int target</div><div class="ttdef"><b>Definition:</b> <a href="a00143_source.html#l00011">ncu_opt_tester.py:11</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a94527f570935fc660405701a6368e271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94527f570935fc660405701a6368e271">&#9670;&nbsp;</a></span>applyMeasurementToRegister()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyMeasurementToRegister </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>target_qubits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply measurement to a set of target qubits, randomly collapsing the qubits proportional to the amplitude and returns the bit string of the qubits in the order they are represented in the vector of indexes, in the form of an unsigned integer. </p>
<dl class="section return"><dt>Returns</dt><dd>std::size_t Integer representing the binary string of the collapsed qubits, ordered by least significant digit corresponding to first qubit in target vector of indices </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_qubits</td><td>Vector of indices of qubits being collapsed </td></tr>
    <tr><td class="paramname">normalize</td><td>Optional argument specifying whether amplitudes shoud be normalized (true) or not (false). Default value is true. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00640">640</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;                                                                                                     {</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;            <span class="comment">// Store current state of training register in it&#39;s integer format</span></div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;            std::size_t <a class="code" href="a00214.html#a0f17b8148d6ff46bd0f0db2953f601fa">val</a> = 0; </div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = target_qubits.size() - 1; j &gt; -1; j--){</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;                <a class="code" href="a00214.html#a0f17b8148d6ff46bd0f0db2953f601fa">val</a> |= (static_cast&lt;DerivedType*&gt;(<span class="keyword">this</span>)-&gt;applyMeasurement(target_qubits[j], normalize) &lt;&lt; j);</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;            } </div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="a00214.html#a0f17b8148d6ff46bd0f0db2953f601fa">val</a>;</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;        }</div><div class="ttc" id="a00214_html_a0f17b8148d6ff46bd0f0db2953f601fa"><div class="ttname"><a href="a00214.html#a0f17b8148d6ff46bd0f0db2953f601fa">QNLP.tagging.tag_file.val</a></div><div class="ttdeci">val</div><div class="ttdef"><b>Definition:</b> <a href="a00122_source.html#l00082">tag_file.py:82</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a99156d389719269b2324aa362d4047e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99156d389719269b2324aa362d4047e4">&#9670;&nbsp;</a></span>applyOraclePhase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyOraclePhase </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bit_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctrlIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply oracle to match given binary index with linearly adjacent controls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bit_pattern</td><td><a class="el" href="a00804.html" title="Class definition for defining and applying an Oracle.">Oracle</a> pattern in binary </td></tr>
    <tr><td class="paramname">ctrlIndices</td><td>Control lines for oracle </td></tr>
    <tr><td class="paramname">target</td><td>Target qubit index to apply Z gate upon </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00524">524</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;                                                                                                               {</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;            <span class="comment">//applyOracleU&lt;decltype(static_cast&lt;DerivedType*&gt;(this)-&gt;getGateZ())&gt;(bit_pattern, ctrlIndices, target, static_cast&lt;DerivedType*&gt;(this)-&gt;getGateZ());</span></div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;            Oracle&lt;DerivedType&gt; oracle;</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;            oracle.bitStringPhaseOracle(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>), bit_pattern, ctrlIndices, <a class="code" href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">target</a> );</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;        }</div><div class="ttc" id="a00221_html_a04d504e3a1d9b0157c4d2d1de832d0ed"><div class="ttname"><a href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">ncu_opt_tester.target</a></div><div class="ttdeci">int target</div><div class="ttdef"><b>Definition:</b> <a href="a00143_source.html#l00011">ncu_opt_tester.py:11</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af63bd0c42ec6867678ada3d48866cd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63bd0c42ec6867678ada3d48866cd49">&#9670;&nbsp;</a></span>applyOracleU() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<div class="memtemplate">
template&lt;class Mat2x2Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyOracleU </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bit_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctrlIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat2x2Type &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>gateLabel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply oracle to match given binary index with non adjacent controls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bit_pattern</td><td><a class="el" href="a00804.html" title="Class definition for defining and applying an Oracle.">Oracle</a> state pattern (bitstring: 0-&gt; |0&gt;, 1-&gt; |1&gt;) </td></tr>
    <tr><td class="paramname">U</td><td>2x2 unitary matrix to apply </td></tr>
    <tr><td class="paramname">ctrlIndices</td><td>Control indices for operation </td></tr>
    <tr><td class="paramname">target</td><td>Target qubit index to apply U on </td></tr>
    <tr><td class="paramname">gateLabel</td><td>Label used to access required cached matrix for <a class="el" href="a00796.html" title="Class definition for applying n-qubit controlled unitary operations.">NCU</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00498">498</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;                                                                                                                                                      {</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;            <a class="code" href="a00804.html#ac75ed4a67e90d65a5290df33fa25ab89">Oracle&lt;DerivedType&gt;::bitStringNCU</a>(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>), bit_pattern, ctrlIndices, <a class="code" href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">target</a>, U, gateLabel);</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;        }</div><div class="ttc" id="a00804_html_ac75ed4a67e90d65a5290df33fa25ab89"><div class="ttname"><a href="a00804.html#ac75ed4a67e90d65a5290df33fa25ab89">QNLP::Oracle::bitStringNCU</a></div><div class="ttdeci">static void bitStringNCU(SimulatorType &amp;s, std::size_t bitstring, const std::vector&lt; std::size_t &gt; &amp;ctrl_indices, const std::size_t target, const Mat2x2Type &amp;U, std::string gateLabel)</div><div class="ttdoc">Takes bitstring as the binary pattern and indices as the qubits to operate upon. Applies the appropri...</div><div class="ttdef"><b>Definition:</b> <a href="a00032_source.html#l00054">oracle.hpp:54</a></div></div>
<div class="ttc" id="a00221_html_a04d504e3a1d9b0157c4d2d1de832d0ed"><div class="ttname"><a href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">ncu_opt_tester.target</a></div><div class="ttdeci">int target</div><div class="ttdef"><b>Definition:</b> <a href="a00143_source.html#l00011">ncu_opt_tester.py:11</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af04b34a18c2677d36020c9ce688eed1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04b34a18c2677d36020c9ce688eed1a">&#9670;&nbsp;</a></span>applyOracleU() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<div class="memtemplate">
template&lt;class Mat2x2Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyOracleU </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bit_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctrlIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>auxIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat2x2Type &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>gateLabel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply oracle to match given binary index with non adjacent controls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bit_pattern</td><td><a class="el" href="a00804.html" title="Class definition for defining and applying an Oracle.">Oracle</a> state pattern (bitstring: 0-&gt; |0&gt;, 1-&gt; |1&gt;) </td></tr>
    <tr><td class="paramname">U</td><td>2x2 unitary matrix to apply </td></tr>
    <tr><td class="paramname">ctrlIndices</td><td>Control indices for operation </td></tr>
    <tr><td class="paramname">auxIndices</td><td>Auxiliary indices for operation </td></tr>
    <tr><td class="paramname">target</td><td>Target qubit index to apply U on </td></tr>
    <tr><td class="paramname">gateLabel</td><td>Label used to access required cached matrix for <a class="el" href="a00796.html" title="Class definition for applying n-qubit controlled unitary operations.">NCU</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00513">513</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;                                                                                                                                                                                              {</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;            <a class="code" href="a00804.html#ac75ed4a67e90d65a5290df33fa25ab89">Oracle&lt;DerivedType&gt;::bitStringNCU</a>(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>), bit_pattern, ctrlIndices, auxIndices, <a class="code" href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">target</a>, U, gateLabel);</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;        }</div><div class="ttc" id="a00804_html_ac75ed4a67e90d65a5290df33fa25ab89"><div class="ttname"><a href="a00804.html#ac75ed4a67e90d65a5290df33fa25ab89">QNLP::Oracle::bitStringNCU</a></div><div class="ttdeci">static void bitStringNCU(SimulatorType &amp;s, std::size_t bitstring, const std::vector&lt; std::size_t &gt; &amp;ctrl_indices, const std::size_t target, const Mat2x2Type &amp;U, std::string gateLabel)</div><div class="ttdoc">Takes bitstring as the binary pattern and indices as the qubits to operate upon. Applies the appropri...</div><div class="ttdef"><b>Definition:</b> <a href="a00032_source.html#l00054">oracle.hpp:54</a></div></div>
<div class="ttc" id="a00221_html_a04d504e3a1d9b0157c4d2d1de832d0ed"><div class="ttname"><a href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">ncu_opt_tester.target</a></div><div class="ttdeci">int target</div><div class="ttdef"><b>Definition:</b> <a href="a00143_source.html#l00011">ncu_opt_tester.py:11</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae01cf864ddcce63c22be913097f347b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01cf864ddcce63c22be913097f347b0">&#9670;&nbsp;</a></span>applyQFT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::applyQFT </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>minIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>maxIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the forward Quantum Fourier transform (<a class="el" href="a00808.html" title="Class definition for performing quantum forward and inverse Fourier transforms.">QFT</a>) to the given register index range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minIdx</td><td>Lowest qubit index of the <a class="el" href="a00808.html" title="Class definition for performing quantum forward and inverse Fourier transforms.">QFT</a> range </td></tr>
    <tr><td class="paramname">maxIdx</td><td>Highest qubit index of the <a class="el" href="a00808.html" title="Class definition for performing quantum forward and inverse Fourier transforms.">QFT</a> range </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00423">423</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;                                                         {</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;            QFT&lt;decltype(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>))&gt;::<a class="code" href="a00932.html#ae01cf864ddcce63c22be913097f347b0">applyQFT</a>(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>), minIdx, maxIdx);</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;        }</div><div class="ttc" id="a00932_html_ae01cf864ddcce63c22be913097f347b0"><div class="ttname"><a href="a00932.html#ae01cf864ddcce63c22be913097f347b0">QNLP::SimulatorGeneral::applyQFT</a></div><div class="ttdeci">void applyQFT(std::size_t minIdx, std::size_t maxIdx)</div><div class="ttdoc">Apply the forward Quantum Fourier transform (QFT) to the given register index range.</div><div class="ttdef"><b>Definition:</b> <a href="a00173_source.html#l00423">Simulator.hpp:423</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="a00173_source.html#l00423">QNLP::SimulatorGeneral&lt; IntelSimulator &gt;::applyQFT()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="a00932_ae01cf864ddcce63c22be913097f347b0_icgraph.png" border="0" usemap="#a00932_ae01cf864ddcce63c22be913097f347b0_icgraph" alt=""/></div>
<map name="a00932_ae01cf864ddcce63c22be913097f347b0_icgraph" id="a00932_ae01cf864ddcce63c22be913097f347b0_icgraph">
<area shape="rect"  title="Apply the forward Quantum Fourier transform (QFT) to the given register index range." alt="" coords="5,29,175,71"/>
</map>
</div>

</div>
</div>
<a id="a6eb9d8d81ad94adddc1b30e03300e741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb9d8d81ad94adddc1b30e03300e741">&#9670;&nbsp;</a></span>collapseToBasisZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::collapseToBasisZ </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>collapseValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply measurement to a target qubit with respect to the Z-basis, collapsing to a specified value (0 or 1). Amplitudes are r-normalized afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td><a class="el" href="a00952.html">The</a> index of the qubit being collapsed </td></tr>
    <tr><td class="paramname">collapseValue</td><td><a class="el" href="a00952.html">The</a> value that the register will be collapsed to (either 0 ro 1). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00671">671</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;                                                                   {</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;            static_cast&lt;DerivedType*&gt;(<span class="keyword">this</span>)-&gt;collapseToBasisZ(<a class="code" href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">target</a>, collapseValue);</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;        }</div><div class="ttc" id="a00221_html_a04d504e3a1d9b0157c4d2d1de832d0ed"><div class="ttname"><a href="a00221.html#a04d504e3a1d9b0157c4d2d1de832d0ed">ncu_opt_tester.target</a></div><div class="ttdeci">int target</div><div class="ttdef"><b>Definition:</b> <a href="a00143_source.html#l00011">ncu_opt_tester.py:11</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a203ad2c406b64490353acab47987b21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203ad2c406b64490353acab47987b21b">&#9670;&nbsp;</a></span>encodeBinToSuperpos_unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::encodeBinToSuperpos_unique </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>reg_memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>reg_auxiliary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bin_patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>len_bin_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode inputted binary strings to the memory register specified as a superposition of states. Note that this implementation does not allow for multiple instances of the same input pattern but allows for 0 to be encoded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg_memory</td><td>std::vector of unsigned integers containing the indices of the circuit's memory register </td></tr>
    <tr><td class="paramname">reg_auxiliary</td><td>std::vector of unsigned integers type containing the indices of the circuit's auxiliary register </td></tr>
    <tr><td class="paramname">bin_patterns</td><td>std::vector of unsigned integers representing the binary patterns to encode </td></tr>
    <tr><td class="paramname">len_bin_pattern</td><td><a class="el" href="a00952.html">The</a> length of the binary patterns being encoded </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00567">567</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;                                                {</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;            EncodeBinIntoSuperpos&lt;DerivedType&gt; encoder(bin_patterns.size(), len_bin_pattern);</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;            encoder.encodeBinInToSuperpos_unique(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>), <a class="code" href="a00222.html#ad9a6dcf24fd48bd7d4853150e1280030">reg_memory</a>, <a class="code" href="a00222.html#a98e4f565503604c2b25fb9f4a98c83af">reg_auxiliary</a>, bin_patterns);</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;        }</div><div class="ttc" id="a00222_html_a98e4f565503604c2b25fb9f4a98c83af"><div class="ttname"><a href="a00222.html#a98e4f565503604c2b25fb9f4a98c83af">QNLP_7qubit_pattern_example.reg_auxiliary</a></div><div class="ttdeci">list reg_auxiliary</div><div class="ttdef"><b>Definition:</b> <a href="a00146_source.html#l00040">QNLP_7qubit_pattern_example.py:40</a></div></div>
<div class="ttc" id="a00222_html_ad9a6dcf24fd48bd7d4853150e1280030"><div class="ttname"><a href="a00222.html#ad9a6dcf24fd48bd7d4853150e1280030">QNLP_7qubit_pattern_example.reg_memory</a></div><div class="ttdeci">list reg_memory</div><div class="ttdef"><b>Definition:</b> <a href="a00146_source.html#l00036">QNLP_7qubit_pattern_example.py:36</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2cc0205185d34a8756670fa138666b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc0205185d34a8756670fa138666b5e">&#9670;&nbsp;</a></span>encodeToRegister()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::encodeToRegister </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>target_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>target_register</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len_bin_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encodes a defined binary pattern into a defined target register (initially in state |00...0&gt;) of all quantum states in the superposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_pattern</td><td><a class="el" href="a00952.html">The</a> binary pattern that is to be encoded </td></tr>
    <tr><td class="paramname">target_register</td><td>Vector containing the indices of the register qubits that the pattern is to be encoded into (beginning at least significant digit). Note, the target register is expected to be in the state consisting of all 0's before the encoding. </td></tr>
    <tr><td class="paramname">Length</td><td>of the binary pattern to be encoded </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00548">548</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;                                          {</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;            <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; len_bin_pattern; i++){</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;                <span class="keywordflow">if</span>(<a class="code" href="a00173.html#a0941781e232472b1673ca065ded3e9aa">IS_SET</a>(target_pattern,i)){</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;                    <a class="code" href="a00932.html#ac4359d766497887ac5a48a1d245a1213">applyGateX</a>(target_register[i]);</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;                }</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;            }</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;        }</div><div class="ttc" id="a00173_html_a0941781e232472b1673ca065ded3e9aa"><div class="ttname"><a href="a00173.html#a0941781e232472b1673ca065ded3e9aa">IS_SET</a></div><div class="ttdeci">#define IS_SET(byte, bit)</div><div class="ttdef"><b>Definition:</b> <a href="a00173_source.html#l00058">Simulator.hpp:58</a></div></div>
<div class="ttc" id="a00932_html_ac4359d766497887ac5a48a1d245a1213"><div class="ttname"><a href="a00932.html#ac4359d766497887ac5a48a1d245a1213">QNLP::SimulatorGeneral::applyGateX</a></div><div class="ttdeci">void applyGateX(std::size_t qubit_idx)</div><div class="ttdoc">Apply the Pauli X gate to the given qubit.</div><div class="ttdef"><b>Definition:</b> <a href="a00173_source.html#l00123">Simulator.hpp:123</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="a00173_source.html#l00609">QNLP::SimulatorGeneral&lt; IntelSimulator &gt;::applyHammingDistanceOverwrite()</a>, and <a class="el" href="a00173_source.html#l00584">QNLP::SimulatorGeneral&lt; IntelSimulator &gt;::applyHammingDistanceRotY()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="a00932_a2cc0205185d34a8756670fa138666b5e_icgraph.png" border="0" usemap="#a00932_a2cc0205185d34a8756670fa138666b5e_icgraph" alt=""/></div>
<map name="a00932_a2cc0205185d34a8756670fa138666b5e_icgraph" id="a00932_a2cc0205185d34a8756670fa138666b5e_icgraph">
<area shape="rect"  title="Encodes a defined binary pattern into a defined target register (initially in state |00...." alt="" coords="276,53,445,94"/>
<area shape="rect"  href="a00932.html#a62363e702fcea7868324c69a076d60ea" title="Computes the relative Hamming distance between the test pattern and the pattern stored in each state ..." alt="" coords="5,5,228,61"/>
<area shape="rect"  href="a00932.html#a879f5f6c2a27305df3b5f0a8ab7552a9" title="Computes the relative Hamming distance between the test pattern and the pattern stored in each state ..." alt="" coords="5,85,228,141"/>
</map>
</div>

</div>
</div>
<a id="af42dcb1233908b2ecaba3d9a1d0dfb77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42dcb1233908b2ecaba3d9a1d0dfb77">&#9670;&nbsp;</a></span>getGateH()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::getGateH </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Hadamard gate; must be overloaded with appropriate return type. </p>
<dl class="section return"><dt>Returns</dt><dd>GateType Templated return type of Hadamard gate </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00238">238</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;                                 {</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;            <span class="keywordflow">return</span> static_cast&lt;DerivedType*&gt;(<span class="keyword">this</span>)-&gt;getGateH();</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="ae9aec8749122ab1ea137c9a78a6273a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9aec8749122ab1ea137c9a78a6273a4">&#9670;&nbsp;</a></span>getGateI()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::getGateI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Identity; must be overloaded with appropriate return type. </p>
<dl class="section return"><dt>Returns</dt><dd>GateType Templated return type of Identity gate </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00231">231</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;                                 {</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;            <span class="keywordflow">return</span> static_cast&lt;DerivedType*&gt;(<span class="keyword">this</span>)-&gt;getGateI();</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="a5732630b0afeecf7fb7e7add27ff0c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5732630b0afeecf7fb7e7add27ff0c53">&#9670;&nbsp;</a></span>getGateX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::getGateX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Pauli-X gate; returns templated type GateType. </p>
<dl class="section return"><dt>Returns</dt><dd>GateType Templated return type of Pauli-X gate </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00209">209</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;                                  {</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;            <span class="keywordflow">return</span> static_cast&lt;DerivedType&amp;&gt;(*this).getGateX();</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="a77f917c600b5f8e6e3275103eadcb021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f917c600b5f8e6e3275103eadcb021">&#9670;&nbsp;</a></span>getGateY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::getGateY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Pauli-Y gate; must be overloaded with appropriate return type. </p>
<dl class="section return"><dt>Returns</dt><dd>GateType Templated return type of Pauli-Y gate </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00217">217</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;                                 {</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;            <span class="keywordflow">return</span> static_cast&lt;DerivedType&amp;&gt;(*this).getGateY();</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="a1cbad6cae3fc4dbb3574bb110487e6b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbad6cae3fc4dbb3574bb110487e6b4">&#9670;&nbsp;</a></span>getGateZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::getGateZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Pauli-Z gate; must be overloaded with appropriate return type. </p>
<dl class="section return"><dt>Returns</dt><dd>GateType Templated return type of Pauli-Z gate </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00224">224</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;                                 {</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;            <span class="keywordflow">return</span> static_cast&lt;DerivedType&amp;&gt;(*this).getGateZ();</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="a106178245fff70419c4de79b26592ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106178245fff70419c4de79b26592ba3">&#9670;&nbsp;</a></span>getNumQubits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::getNumQubits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of Qubits. </p>
<dl class="section return"><dt>Returns</dt><dd>std::size_t Number of qubits in register </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00413">413</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;                                {</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;            <span class="keywordflow">return</span> static_cast&lt;DerivedType*&gt;(<span class="keyword">this</span>)-&gt;getNumQubits();    </div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;        }</div></div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="a00173_source.html#l00357">QNLP::SimulatorGeneral&lt; IntelSimulator &gt;::applyGateCSwap()</a>, and <a class="el" href="a00176_source.html#l00095">TEST_CASE()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="a00932_a106178245fff70419c4de79b26592ba3_icgraph.png" border="0" usemap="#a00932_a106178245fff70419c4de79b26592ba3_icgraph" alt=""/></div>
<map name="a00932_a106178245fff70419c4de79b26592ba3_icgraph" id="a00932_a106178245fff70419c4de79b26592ba3_icgraph">
<area shape="rect"  title="Get the number of Qubits." alt="" coords="291,35,460,76"/>
<area shape="rect"  href="a00932.html#ac3c00b65cc011c4a6bf0478e9d4a7edf" title="Controlled SWAP gate." alt="" coords="5,5,243,47"/>
<area shape="rect"  href="a00176.html#a834ecf737c9ddf382656bb9a5a295df2" title="Test the Simulator interface." alt="" coords="74,71,174,98"/>
</map>
</div>

</div>
</div>
<a id="a8d9e49aa9ced48d248d6d81a6f7b7a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9e49aa9ced48d248d6d81a6f7b7a54">&#9670;&nbsp;</a></span>getQubitRegister()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::getQubitRegister </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the underlying qubit register object. </p>
<dl class="section return"><dt>Returns</dt><dd>decltype(auto) the underlying bound qubit register </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00404">404</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;                                         { </div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;           <span class="keywordflow">return</span> static_cast&lt;DerivedType*&gt;(<span class="keyword">this</span>)-&gt;getQubitRegister();</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="adead1b90156ed331ab4146c27f8ec37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adead1b90156ed331ab4146c27f8ec37f">&#9670;&nbsp;</a></span>groupQubits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::groupQubits </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>reg_auxiliary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lsb</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Group all set qubits to MSB in register (ie |010100&gt; -&gt; |000011&gt;) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg_mem</td><td><a class="el" href="a00952.html">The</a> indices of the qubits to perform operation upon </td></tr>
    <tr><td class="paramname">reg_auxiliary</td><td><a class="el" href="a00952.html">The</a> auxiliary control qubit register set to |......10&gt; at the beginning, and guaranteed to be set the same at end. </td></tr>
    <tr><td class="paramname">lsb</td><td>Shifts to LSB position in register if true; MSB otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00656">656</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;                                                                                 {</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;            assert( <a class="code" href="a00222.html#a98e4f565503604c2b25fb9f4a98c83af">reg_auxiliary</a>.size() &gt;= 2);</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;            <span class="keyword">const</span> std::vector&lt;std::size_t&gt; reg_ctrl ( <a class="code" href="a00222.html#a98e4f565503604c2b25fb9f4a98c83af">reg_auxiliary</a>.end()-2, <a class="code" href="a00222.html#a98e4f565503604c2b25fb9f4a98c83af">reg_auxiliary</a>.end() );</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;            <span class="keyword">const</span> std::vector&lt;std::size_t&gt; sub_reg (<a class="code" href="a00222.html#a98e4f565503604c2b25fb9f4a98c83af">reg_auxiliary</a>.begin(), <a class="code" href="a00222.html#a98e4f565503604c2b25fb9f4a98c83af">reg_auxiliary</a>.end()-2 ) ;</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;            <a class="code" href="a00788.html#a42f4ea5b92fc4c5856b953ae318c348c">BitGroup&lt;DerivedType&gt;::bit_group</a>(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>), sub_reg, reg_ctrl, lsb);</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;        }</div><div class="ttc" id="a00222_html_a98e4f565503604c2b25fb9f4a98c83af"><div class="ttname"><a href="a00222.html#a98e4f565503604c2b25fb9f4a98c83af">QNLP_7qubit_pattern_example.reg_auxiliary</a></div><div class="ttdeci">list reg_auxiliary</div><div class="ttdef"><b>Definition:</b> <a href="a00146_source.html#l00040">QNLP_7qubit_pattern_example.py:40</a></div></div>
<div class="ttc" id="a00788_html_a42f4ea5b92fc4c5856b953ae318c348c"><div class="ttname"><a href="a00788.html#a42f4ea5b92fc4c5856b953ae318c348c">QNLP::BitGroup::bit_group</a></div><div class="ttdeci">static void bit_group(SimulatorType &amp;qSim, const std::vector&lt; std::size_t &gt; &amp;qreg_idx, const std::vector&lt; std::size_t &gt; &amp;qaux_idx, bool lsb=true)</div><div class="ttdoc">Swaps all qubits in register indices given by qreg_idx to their right-most positions....</div><div class="ttdef"><b>Definition:</b> <a href="a00014_source.html#l00114">bit_group.hpp:114</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a363ca18f6710cc1f4bcdb0f4f27aa197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363ca18f6710cc1f4bcdb0f4f27aa197">&#9670;&nbsp;</a></span>initCaches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::initCaches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialise caches used in <a class="el" href="a00796.html" title="Class definition for applying n-qubit controlled unitary operations.">NCU</a> operation. </p>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00687">687</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;                         {</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;<span class="preprocessor">            #if defined(__INTEL_COMPILER) || defined(__INTEL_LLVM_COMPILER)</span></div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;            std::experimental::any_cast&lt;NCU&lt;DerivedType&gt;&amp;&gt;(<a class="code" href="a00932.html#ab74189d7b20e6932fd6d35a6153bf063">sim_ncu</a>).initialiseMaps(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>), 16);</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;<span class="preprocessor">            #else</span></div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;            std::any_cast&lt;NCU&lt;DerivedType&gt;&amp;&gt;(<a class="code" href="a00932.html#ab74189d7b20e6932fd6d35a6153bf063">sim_ncu</a>).initialiseMaps(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>), 16);</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;<span class="preprocessor">            #endif</span></div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;        }</div><div class="ttc" id="a00932_html_ab74189d7b20e6932fd6d35a6153bf063"><div class="ttname"><a href="a00932.html#ab74189d7b20e6932fd6d35a6153bf063">QNLP::SimulatorGeneral::sim_ncu</a></div><div class="ttdeci">std::any sim_ncu</div><div class="ttdef"><b>Definition:</b> <a href="a00173_source.html#l00104">Simulator.hpp:104</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3afa18d6ef2097e820edf366b21943be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afa18d6ef2097e820edf366b21943be">&#9670;&nbsp;</a></span>initRegister()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::initRegister </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Re)Initialise the underlying register of the encapsulated simulator to well-defined state (|0....0&gt;) </p>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00679">679</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;                           {</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;            static_cast&lt;DerivedType&amp;&gt;(*this).initRegister();</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="ae50f41419d061cef652876033aa7844c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50f41419d061cef652876033aa7844c">&#9670;&nbsp;</a></span>InvertRegister()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::InvertRegister </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>minIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>maxIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert the register about the given indides: 0,1,2...n-1,n -&gt; n,n-1,...,1,0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minIdx</td><td><a class="el" href="a00952.html">The</a> lower index of the inversion </td></tr>
    <tr><td class="paramname">maxIdx</td><td><a class="el" href="a00952.html">The</a> upper index of the inversion </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00776">776</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;                                                                                 {</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> range2 = ((maxIdx - minIdx)%2 == 1) ? (maxIdx - minIdx)/2 +1 : (maxIdx - minIdx)/2;</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;            <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = 0; idx &lt; range2; idx++){</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;                <a class="code" href="a00932.html#ab5d968b4660a5a095825c8139abc5bdd">applyGateSwap</a>(minIdx+idx, maxIdx-idx);</div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;            }</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;        }</div><div class="ttc" id="a00932_html_ab5d968b4660a5a095825c8139abc5bdd"><div class="ttname"><a href="a00932.html#ab5d968b4660a5a095825c8139abc5bdd">QNLP::SimulatorGeneral::applyGateSwap</a></div><div class="ttdeci">void applyGateSwap(std::size_t qubit_idx0, std::size_t qubit_idx1)</div><div class="ttdoc">Swap the qubits at the given indices.</div><div class="ttdef"><b>Definition:</b> <a href="a00173_source.html#l00304">Simulator.hpp:304</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="acdbbba66d5941954ed70b9edc0e5174d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbbba66d5941954ed70b9edc0e5174d">&#9670;&nbsp;</a></span>matrixSqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<div class="memtemplate">
template&lt;class Mat2x2Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Mat2x2Type <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::matrixSqrt </td>
          <td>(</td>
          <td class="paramtype">const Mat2x2Type &amp;&#160;</td>
          <td class="paramname"><em>U</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the unitary matrix square root (U == VV, where V is returned) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mat2x2Type</td><td>Matrix type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>Unitary matrix to be rooted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>openqu::TinyMatrix&lt;Type, 2, 2, 32&gt; V such that VV == U </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00729">729</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;                                                  {</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;            Mat2x2Type V(U);</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;            std::complex&lt;double&gt; delta = U(0,0)*U(1,1) - U(0,1)*U(1,0);</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;            std::complex&lt;double&gt; tau = U(0,0) + U(1,1);</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;            std::complex&lt;double&gt; s = sqrt(delta);</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;            std::complex&lt;double&gt; t = sqrt(tau + 2.0*s);</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;            <span class="comment">//must be a way to vectorise these; TinyMatrix have a scale/shift option?</span></div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;            V(0,0) += s;</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;            V(1,1) += s;</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;            std::complex&lt;double&gt; scale_factor(1.,0.);</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;            scale_factor/=t;</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;            V(0,0) *= scale_factor; <span class="comment">//(std::complex&lt;double&gt;(1.,0.)/t);</span></div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;            V(0,1) *= scale_factor; <span class="comment">//(1/t);</span></div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;            V(1,0) *= scale_factor; <span class="comment">//(1/t);</span></div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;            V(1,1) *= scale_factor; <span class="comment">//(1/t);</span></div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;            <span class="keywordflow">return</span> V;</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="a04f644b1df965c72b3b06af4d9ff4d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f644b1df965c72b3b06af4d9ff4d55">&#9670;&nbsp;</a></span>PrintStates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::PrintStates </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>qubits</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the string x and then for each state of the specified qubits in the superposition, prints each its amplitude, followed by state and then by the probability of that state. Note that this state observation method is not a permitted quantum operation, however it is provided for convenience and debugging/testing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>String to be printed to stdout </td></tr>
    <tr><td class="paramname">qubits</td><td>Indices of qubits in register to be printed </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00717">717</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;                                                                    {}){</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;            static_cast&lt;DerivedType*&gt;(<span class="keyword">this</span>)-&gt;PrintStates(<a class="code" href="a00222.html#ad6c51c271548793a2db3af788b1beb6f">x</a>, qubits);</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;        }</div><div class="ttc" id="a00222_html_ad6c51c271548793a2db3af788b1beb6f"><div class="ttname"><a href="a00222.html#ad6c51c271548793a2db3af788b1beb6f">QNLP_7qubit_pattern_example.x</a></div><div class="ttdeci">x</div><div class="ttdef"><b>Definition:</b> <a href="a00146_source.html#l00149">QNLP_7qubit_pattern_example.py:149</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="acf21cf93cffc21565d1708f7362a238e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf21cf93cffc21565d1708f7362a238e">&#9670;&nbsp;</a></span>subReg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::subReg </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>r0_minIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>r0_maxIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>r1_minIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>r1_maxIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies |r1&gt;|r2&gt; -&gt; |r1&gt;|r1-r2&gt; </p>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00448">448</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;                                                                                                       {</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;            Arithmetic&lt;decltype(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>))&gt;::sub_reg(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>), r0_minIdx, r0_maxIdx, r1_minIdx, r1_maxIdx);</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<a id="a67847e4b34c222c49e0466ccdc8961c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67847e4b34c222c49e0466ccdc8961c9">&#9670;&nbsp;</a></span>sumReg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::sumReg </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>r0_minIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>r0_maxIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>r1_minIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>r1_maxIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies |r1&gt;|r2&gt; -&gt; |r1&gt;|r1+r2&gt; </p>

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00441">441</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;                                                                                                       {</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;            Arithmetic&lt;decltype(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>))&gt;::sum_reg(static_cast&lt;DerivedType&amp;&gt;(*<span class="keyword">this</span>), r0_minIdx, r0_maxIdx, r1_minIdx, r1_maxIdx);</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;        }</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="af4f1b3355061a1e13fffebb71176b353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f1b3355061a1e13fffebb71176b353">&#9670;&nbsp;</a></span>DerivedType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; DerivedType &gt;::DerivedType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00091">91</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>

</div>
</div>
<a id="ab74189d7b20e6932fd6d35a6153bf063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74189d7b20e6932fd6d35a6153bf063">&#9670;&nbsp;</a></span>sim_ncu</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::any <a class="el" href="a00932.html">QNLP::SimulatorGeneral</a>&lt; <a class="el" href="a00932.html#af4f1b3355061a1e13fffebb71176b353">DerivedType</a> &gt;::sim_ncu</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00173_source.html#l00104">104</a> of file <a class="el" href="a00173_source.html">Simulator.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00173_source.html#l00703">QNLP::SimulatorGeneral&lt; IntelSimulator &gt;::addUToCache()</a>, <a class="el" href="a00173_source.html#l00462">QNLP::SimulatorGeneral&lt; IntelSimulator &gt;::applyGateNCU()</a>, <a class="el" href="a00173_source.html#l00687">QNLP::SimulatorGeneral&lt; IntelSimulator &gt;::initCaches()</a>, and <a class="el" href="a00173_source.html#l00077">QNLP::SimulatorGeneral&lt; IntelSimulator &gt;::SimulatorGeneral()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/mlxd/Desktop/tmp/intel-qnlp-api/modules/simulator/<a class="el" href="a00173_source.html">Simulator.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00192.html">QNLP</a></li><li class="navelem"><a class="el" href="a00932.html">SimulatorGeneral</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
