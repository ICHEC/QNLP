<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QNLP: QNLP::NCU&lt; SimulatorType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">QNLP
   &#160;<span id="projectnumber">v1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a00787.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">QNLP::NCU&lt; SimulatorType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class definition for applying n-qubit controlled unitary operations.  
 <a href="a00787.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00026_source.html">ncu.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for QNLP::NCU&lt; SimulatorType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="a00785.png" border="0" usemap="#_q_n_l_p_1_1_n_c_u_3_01_simulator_type_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="_q_n_l_p_1_1_n_c_u_3_01_simulator_type_01_4_coll__map" id="_q_n_l_p_1_1_n_c_u_3_01_simulator_type_01_4_coll__map">
<area shape="rect"  title="Class definition for applying n&#45;qubit controlled unitary operations." alt="" coords="271,557,475,796"/>
<area shape="rect"  title=" " alt="" coords="300,373,441,495"/>
<area shape="rect"  title="STL class." alt="" coords="261,182,403,274"/>
<area shape="rect"  title=" " alt="" coords="107,381,269,487"/>
<area shape="rect"  title=" " alt="" coords="450,13,489,90"/>
<area shape="rect"  title="STL class." alt="" coords="427,189,592,267"/>
<area shape="rect"  title=" " alt="" coords="313,13,351,90"/>
<area shape="rect"  href="a00791.html" title="For the 5+ controlled NCX decomposition routines defined within https://arxiv.org/pdf/quant&#45;ph/950301..." alt="" coords="5,160,197,296"/>
<area shape="rect"  title=" " alt="" coords="465,388,599,480"/>
<area shape="rect"  title="STL class." alt="" coords="616,189,696,267"/>
<area shape="rect"  title="STL class." alt="" coords="593,5,719,97"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00791.html">OptParamsCX</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the 5+ controlled NCX decomposition routines defined within <a href="https://arxiv.org/pdf/quant-ph/9503016.pdf">https://arxiv.org/pdf/quant-ph/9503016.pdf</a>.  <a href="a00791.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa21f56c1664d0761cb5ef497f1d3c024"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00787.html#aa21f56c1664d0761cb5ef497f1d3c024">NCU</a> ()</td></tr>
<tr class="memdesc:aa21f56c1664d0761cb5ef497f1d3c024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="a00787.html" title="Class definition for applying n-qubit controlled unitary operations.">NCU</a> object.  <a href="#aa21f56c1664d0761cb5ef497f1d3c024">More...</a><br /></td></tr>
<tr class="separator:aa21f56c1664d0761cb5ef497f1d3c024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eab8ba9c4a41bc18bf0214d6d40fe4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00787.html#a6eab8ba9c4a41bc18bf0214d6d40fe4f">NCU</a> (SimulatorType &amp;qSim)</td></tr>
<tr class="memdesc:a6eab8ba9c4a41bc18bf0214d6d40fe4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="a00787.html" title="Class definition for applying n-qubit controlled unitary operations.">NCU</a> object.  <a href="#a6eab8ba9c4a41bc18bf0214d6d40fe4f">More...</a><br /></td></tr>
<tr class="separator:a6eab8ba9c4a41bc18bf0214d6d40fe4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b0a71f74e7420c533c5bfa318584c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00787.html#a99b0a71f74e7420c533c5bfa318584c5">~NCU</a> ()</td></tr>
<tr class="memdesc:a99b0a71f74e7420c533c5bfa318584c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the <a class="el" href="a00787.html" title="Class definition for applying n-qubit controlled unitary operations.">NCU</a> object.  <a href="#a99b0a71f74e7420c533c5bfa318584c5">More...</a><br /></td></tr>
<tr class="separator:a99b0a71f74e7420c533c5bfa318584c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac911ebbd5c14ebe7ae37737b8c2b6182"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00787.html#ac911ebbd5c14ebe7ae37737b8c2b6182">initialiseMaps</a> (SimulatorType &amp;qSim, std::size_t num_ctrl_lines)</td></tr>
<tr class="memdesc:ac911ebbd5c14ebe7ae37737b8c2b6182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the PauliX and the given unitary U to the maps.  <a href="#ac911ebbd5c14ebe7ae37737b8c2b6182">More...</a><br /></td></tr>
<tr class="separator:ac911ebbd5c14ebe7ae37737b8c2b6182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf18406d1ea241e16764e1ebfbf175a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00787.html#abf18406d1ea241e16764e1ebfbf175a5">addToMaps</a> (SimulatorType &amp;qSim, std::string U_label, const <a class="el" href="a00787.html#ac430497a73eb8cf4312c065bca719c26">Mat2x2Type</a> &amp;U, std::size_t num_ctrl_lines)</td></tr>
<tr class="memdesc:abf18406d1ea241e16764e1ebfbf175a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given unitary matrix to the maps up to the required depth.  <a href="#abf18406d1ea241e16764e1ebfbf175a5">More...</a><br /></td></tr>
<tr class="separator:abf18406d1ea241e16764e1ebfbf175a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ac9e40555c41856235dbd8e3be0d46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00935.html">GateCache</a>&lt; SimulatorType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00787.html#ac3ac9e40555c41856235dbd8e3be0d46">getGateCache</a> ()</td></tr>
<tr class="memdesc:ac3ac9e40555c41856235dbd8e3be0d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Map of cached gates. Keys are strings, and values are vectors of paired (gate, gate adjoint) types where the index give the value of (gate)^(1/2^i)  <a href="#ac3ac9e40555c41856235dbd8e3be0d46">More...</a><br /></td></tr>
<tr class="separator:ac3ac9e40555c41856235dbd8e3be0d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18bd36e85b79be7bd482f26cda350d85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00787.html#a18bd36e85b79be7bd482f26cda350d85">clearMaps</a> ()</td></tr>
<tr class="memdesc:a18bd36e85b79be7bd482f26cda350d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the maps of stored sqrt matrices.  <a href="#a18bd36e85b79be7bd482f26cda350d85">More...</a><br /></td></tr>
<tr class="separator:a18bd36e85b79be7bd482f26cda350d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af455a12f17698722468f2bcd4b30a03f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00787.html#af455a12f17698722468f2bcd4b30a03f">applyNQubitControl</a> (SimulatorType &amp;qSim, const std::vector&lt; std::size_t &gt; ctrlIndices, const std::vector&lt; std::size_t &gt; auxIndices, const unsigned int qTarget, const std::string gateLabel, const <a class="el" href="a00787.html#ac430497a73eb8cf4312c065bca719c26">Mat2x2Type</a> &amp;U, const std::size_t depth)</td></tr>
<tr class="memdesc:af455a12f17698722468f2bcd4b30a03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose n-qubit controlled op into 1 and 2 qubit gates. Control indices can be in any specified location. Ensure the gate cache has been populated with the appropriate gate type before running. This avoids O(n) checking of the container at each call for the associated gates.  <a href="#af455a12f17698722468f2bcd4b30a03f">More...</a><br /></td></tr>
<tr class="separator:af455a12f17698722468f2bcd4b30a03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8a86e0603ce137658f27a2f9b30b72"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00787.html#a2f8a86e0603ce137658f27a2f9b30b72">get_op_calls</a> (std::size_t num_ctrl_lines)</td></tr>
<tr class="memdesc:a2f8a86e0603ce137658f27a2f9b30b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of 2-qubit operations a non optimised decomposition will make. Cache intermediate results.  <a href="#a2f8a86e0603ce137658f27a2f9b30b72">More...</a><br /></td></tr>
<tr class="separator:a2f8a86e0603ce137658f27a2f9b30b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14cf264b2e8440bd24c356cdd6cc3dd"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00787.html#ae14cf264b2e8440bd24c356cdd6cc3dd">get_ops_for_params</a> (std::size_t l, std::size_t m)</td></tr>
<tr class="memdesc:ae14cf264b2e8440bd24c356cdd6cc3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to get optimised number of 2-gate ops for given decomposition params.  <a href="#ae14cf264b2e8440bd24c356cdd6cc3dd">More...</a><br /></td></tr>
<tr class="separator:ae14cf264b2e8440bd24c356cdd6cc3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ea045ed7096c4e6c0001db5a3e0cd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00791.html">OptParamsCX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00787.html#a02ea045ed7096c4e6c0001db5a3e0cd5">find_optimal_params</a> (std::size_t num_ctrl_lines)</td></tr>
<tr class="memdesc:a02ea045ed7096c4e6c0001db5a3e0cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of 2-qubit operations an optimised decomposition will make for nCX. Caches intermediate results.  <a href="#a02ea045ed7096c4e6c0001db5a3e0cd5">More...</a><br /></td></tr>
<tr class="separator:a02ea045ed7096c4e6c0001db5a3e0cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ac430497a73eb8cf4312c065bca719c26"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00787.html#ac430497a73eb8cf4312c065bca719c26">Mat2x2Type</a> = decltype(std::declval&lt; SimulatorType &gt;().getGateX())</td></tr>
<tr class="separator:ac430497a73eb8cf4312c065bca719c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a1f01335e87242dd9064ae46ea71eb003"><td class="memItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00787.html#a1f01335e87242dd9064ae46ea71eb003">num_gate_ops</a></td></tr>
<tr class="separator:a1f01335e87242dd9064ae46ea71eb003"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a00ae431de3e099653ea403b04879111e"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00787.html#a00ae431de3e099653ea403b04879111e">default_gates</a></td></tr>
<tr class="separator:a00ae431de3e099653ea403b04879111e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9203cd5393e0537cc604a25a59f4c716"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::size_t, std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00787.html#a9203cd5393e0537cc604a25a59f4c716">op_call_counts_CX</a></td></tr>
<tr class="separator:a9203cd5393e0537cc604a25a59f4c716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21990a8ce5be79b6311f7a4d59aa3a3a"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::size_t, <a class="el" href="a00791.html">OptParamsCX</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00787.html#a21990a8ce5be79b6311f7a4d59aa3a3a">opt_op_call_params_CX</a></td></tr>
<tr class="separator:a21990a8ce5be79b6311f7a4d59aa3a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac427299b83ca823451eed3d0ac3d4be9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00935.html">GateCache</a>&lt; SimulatorType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">gate_cache</a></td></tr>
<tr class="separator:ac427299b83ca823451eed3d0ac3d4be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class SimulatorType&gt;<br />
class QNLP::NCU&lt; SimulatorType &gt;</h3>

<p>Class definition for applying n-qubit controlled unitary operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SimulatorType</td><td>Class Simulator Type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00026_source.html#l00029">29</a> of file <a class="el" href="a00026_source.html">ncu.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac430497a73eb8cf4312c065bca719c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac430497a73eb8cf4312c065bca719c26">&#9670;&nbsp;</a></span>Mat2x2Type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SimulatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00787.html">QNLP::NCU</a>&lt; SimulatorType &gt;::<a class="el" href="a00787.html#ac430497a73eb8cf4312c065bca719c26">Mat2x2Type</a> =  decltype(std::declval&lt;SimulatorType&gt;().getGateX())</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00026_source.html#l00055">55</a> of file <a class="el" href="a00026_source.html">ncu.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa21f56c1664d0761cb5ef497f1d3c024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21f56c1664d0761cb5ef497f1d3c024">&#9670;&nbsp;</a></span>NCU() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SimulatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00787.html">QNLP::NCU</a>&lt; SimulatorType &gt;::<a class="el" href="a00787.html">NCU</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="a00787.html" title="Class definition for applying n-qubit controlled unitary operations.">NCU</a> object. </p>

<p class="definition">Definition at line <a class="el" href="a00026_source.html#l00064">64</a> of file <a class="el" href="a00026_source.html">ncu.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;                  {</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;                <span class="comment">//Optimised building block routines for nCX</span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;                <span class="keywordflow">if</span>(<a class="code" href="a00787.html#a9203cd5393e0537cc604a25a59f4c716">op_call_counts_CX</a>.size() == 0){</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;                    <a class="code" href="a00787.html#a9203cd5393e0537cc604a25a59f4c716">op_call_counts_CX</a>[3] = 13;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;                    <a class="code" href="a00787.html#a9203cd5393e0537cc604a25a59f4c716">op_call_counts_CX</a>[5] = 60;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;                }</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;            };</div><div class="ttc" id="a00787_html_a9203cd5393e0537cc604a25a59f4c716"><div class="ttname"><a href="a00787.html#a9203cd5393e0537cc604a25a59f4c716">QNLP::NCU::op_call_counts_CX</a></div><div class="ttdeci">std::unordered_map&lt; std::size_t, std::size_t &gt; op_call_counts_CX</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00047">ncu.hpp:47</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="a00026_source.html#l00047">QNLP::NCU&lt; SimulatorType &gt;::op_call_counts_CX</a>.</p>

</div>
</div>
<a id="a6eab8ba9c4a41bc18bf0214d6d40fe4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eab8ba9c4a41bc18bf0214d6d40fe4f">&#9670;&nbsp;</a></span>NCU() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SimulatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00787.html">QNLP::NCU</a>&lt; SimulatorType &gt;::<a class="el" href="a00787.html">NCU</a> </td>
          <td>(</td>
          <td class="paramtype">SimulatorType &amp;&#160;</td>
          <td class="paramname"><em>qSim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="a00787.html" title="Class definition for applying n-qubit controlled unitary operations.">NCU</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qSim</td><td>Instance of quantum simulator </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00026_source.html#l00077">77</a> of file <a class="el" href="a00026_source.html">ncu.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;                                     : <a class="code" href="a00787.html#aa21f56c1664d0761cb5ef497f1d3c024">NCU</a>(){</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;                <a class="code" href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">gate_cache</a> = GateCache&lt;SimulatorType&gt;(qSim);</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;            }</div><div class="ttc" id="a00787_html_ac427299b83ca823451eed3d0ac3d4be9"><div class="ttname"><a href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">QNLP::NCU::gate_cache</a></div><div class="ttdeci">GateCache&lt; SimulatorType &gt; gate_cache</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00051">ncu.hpp:51</a></div></div>
<div class="ttc" id="a00787_html_aa21f56c1664d0761cb5ef497f1d3c024"><div class="ttname"><a href="a00787.html#aa21f56c1664d0761cb5ef497f1d3c024">QNLP::NCU::NCU</a></div><div class="ttdeci">NCU()</div><div class="ttdoc">Construct a new NCU object.</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00064">ncu.hpp:64</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="a00026_source.html#l00051">QNLP::NCU&lt; SimulatorType &gt;::gate_cache</a>.</p>

</div>
</div>
<a id="a99b0a71f74e7420c533c5bfa318584c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b0a71f74e7420c533c5bfa318584c5">&#9670;&nbsp;</a></span>~NCU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SimulatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00787.html">QNLP::NCU</a>&lt; SimulatorType &gt;::~<a class="el" href="a00787.html">NCU</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the <a class="el" href="a00787.html" title="Class definition for applying n-qubit controlled unitary operations.">NCU</a> object. </p>

<p class="definition">Definition at line <a class="el" href="a00026_source.html#l00085">85</a> of file <a class="el" href="a00026_source.html">ncu.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;                  {</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;                <a class="code" href="a00787.html#a18bd36e85b79be7bd482f26cda350d85">clearMaps</a>();</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                <a class="code" href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">gate_cache</a>.clearCache();</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;            };</div><div class="ttc" id="a00787_html_ac427299b83ca823451eed3d0ac3d4be9"><div class="ttname"><a href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">QNLP::NCU::gate_cache</a></div><div class="ttdeci">GateCache&lt; SimulatorType &gt; gate_cache</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00051">ncu.hpp:51</a></div></div>
<div class="ttc" id="a00787_html_a18bd36e85b79be7bd482f26cda350d85"><div class="ttname"><a href="a00787.html#a18bd36e85b79be7bd482f26cda350d85">QNLP::NCU::clearMaps</a></div><div class="ttdeci">void clearMaps()</div><div class="ttdoc">Clears the maps of stored sqrt matrices.</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00121">ncu.hpp:121</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="a00026_source.html#l00121">QNLP::NCU&lt; SimulatorType &gt;::clearMaps()</a>, and <a class="el" href="a00026_source.html#l00051">QNLP::NCU&lt; SimulatorType &gt;::gate_cache</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="a00787_a99b0a71f74e7420c533c5bfa318584c5_cgraph.png" border="0" usemap="#a00787_a99b0a71f74e7420c533c5bfa318584c5_cgraph" alt=""/></div>
<map name="a00787_a99b0a71f74e7420c533c5bfa318584c5_cgraph" id="a00787_a99b0a71f74e7420c533c5bfa318584c5_cgraph">
<area shape="rect"  title="Destroy the NCU object." alt="" coords="5,5,144,32"/>
<area shape="rect"  href="a00787.html#a18bd36e85b79be7bd482f26cda350d85" title="Clears the maps of stored sqrt matrices." alt="" coords="192,5,356,32"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abf18406d1ea241e16764e1ebfbf175a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf18406d1ea241e16764e1ebfbf175a5">&#9670;&nbsp;</a></span>addToMaps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SimulatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00787.html">QNLP::NCU</a>&lt; SimulatorType &gt;::addToMaps </td>
          <td>(</td>
          <td class="paramtype">SimulatorType &amp;&#160;</td>
          <td class="paramname"><em>qSim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>U_label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00787.html#ac430497a73eb8cf4312c065bca719c26">Mat2x2Type</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_ctrl_lines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the given unitary matrix to the maps up to the required depth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00026_source.html#l00104">104</a> of file <a class="el" href="a00026_source.html">ncu.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;                                                                                                                  {</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;                <a class="code" href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">gate_cache</a>.addToCache(qSim, U_label, U, num_ctrl_lines);</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;            }</div><div class="ttc" id="a00787_html_ac427299b83ca823451eed3d0ac3d4be9"><div class="ttname"><a href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">QNLP::NCU::gate_cache</a></div><div class="ttdeci">GateCache&lt; SimulatorType &gt; gate_cache</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00051">ncu.hpp:51</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="a00026_source.html#l00051">QNLP::NCU&lt; SimulatorType &gt;::gate_cache</a>.</p>

</div>
</div>
<a id="af455a12f17698722468f2bcd4b30a03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af455a12f17698722468f2bcd4b30a03f">&#9670;&nbsp;</a></span>applyNQubitControl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SimulatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00787.html">QNLP::NCU</a>&lt; SimulatorType &gt;::applyNQubitControl </td>
          <td>(</td>
          <td class="paramtype">SimulatorType &amp;&#160;</td>
          <td class="paramname"><em>qSim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>ctrlIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>auxIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>qTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>gateLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00787.html#ac430497a73eb8cf4312c065bca719c26">Mat2x2Type</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompose n-qubit controlled op into 1 and 2 qubit gates. Control indices can be in any specified location. Ensure the gate cache has been populated with the appropriate gate type before running. This avoids O(n) checking of the container at each call for the associated gates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>ComplexDP or ComplexSP </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qReg</td><td>Qubit register </td></tr>
    <tr><td class="paramname">ctrlIndices</td><td>Vector of indices for control lines </td></tr>
    <tr><td class="paramname">qTarget</td><td>Target qubit for the unitary matrix U </td></tr>
    <tr><td class="paramname">U</td><td>Unitary matrix, U </td></tr>
    <tr><td class="paramname">depth</td><td>Depth of recursion. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00026_source.html#l00136">136</a> of file <a class="el" href="a00026_source.html">ncu.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;             {</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;                <span class="comment">//No safety checks; be aware of what is physically possible (qTarget not in control_indices)</span></div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;                <span class="keywordtype">int</span> local_depth = depth + 1;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;                <span class="comment">//Determine the range over which the qubits exist; consider as a count of the control ops, hence +1 since extremeties included</span></div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;                std::size_t cOps = ctrlIndices.size();</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;                <span class="comment">//This can be generalised to find a more optimal set of splitting parameters. Using default example breakdown given in Barenco et al (&#39;95) for now.</span></div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="comment">/*                if( (cOps &gt;= 6) &amp;&amp; (auxIndices.size() &gt;= 1) &amp;&amp; (gateLabel == &quot;X&quot;) &amp;&amp; (depth == 0) ){</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="comment">                    auto params = find_optimal_params( ctrlIndices.size() );</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="comment">                    //Need at least 1 aux qubit to perform decomposition</span></div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="comment">                    assert( auxIndices.size() &gt; 0);</span></div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="comment">                    </span></div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="comment">                    //Gate step 1 setup</span></div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="comment">                    assert( ctrlIndices.size() &gt;= params.m );</span></div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="comment">                    std::vector&lt;std::size_t&gt; subMCtrlIndicesNCX(ctrlIndices.begin(), ctrlIndices.begin() + params.m);</span></div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;<span class="comment">                    std::vector&lt;std::size_t&gt; subMAuxIndicesNCX(ctrlIndices.begin() + params.m,ctrlIndices.end());</span></div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="comment">                    subMAuxIndicesNCX.push_back(qTarget);</span></div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="comment">                    //Gate step 2 setup</span></div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;<span class="comment">                    std::vector&lt;std::size_t&gt; subLCtrlIndicesNCX(ctrlIndices.begin() + params.m, ctrlIndices.end());</span></div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="comment">                    subLCtrlIndicesNCX.push_back(auxIndices[0]);</span></div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;<span class="comment">                    std::vector&lt;std::size_t&gt; subLAuxIndicesNCX(ctrlIndices.begin(), ctrlIndices.begin() + params.m);</span></div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;<span class="comment">                    applyNQubitControl(qSim, subMCtrlIndicesNCX, subMAuxIndicesNCX, auxIndices[0], &quot;X&quot;, qSim.getGateX(), 0 );</span></div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;<span class="comment">                    applyNQubitControl(qSim, subLCtrlIndicesNCX, subLAuxIndicesNCX, qTarget, &quot;X&quot;, qSim.getGateX(), 0 );</span></div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;<span class="comment">                    applyNQubitControl(qSim, subMCtrlIndicesNCX, subMAuxIndicesNCX, auxIndices[0], &quot;X&quot;, qSim.getGateX(), 0 );</span></div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;<span class="comment">                    applyNQubitControl(qSim, subLCtrlIndicesNCX, subLAuxIndicesNCX, qTarget, &quot;X&quot;, qSim.getGateX(), 0 );</span></div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;<span class="comment">                }</span></div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;<span class="comment">*/</span></div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                <span class="keywordflow">if</span>( (cOps &gt;= 5) &amp;&amp; ( auxIndices.size() &gt;= cOps-2 ) &amp;&amp; (gateLabel == <span class="stringliteral">&quot;X&quot;</span>) &amp;&amp; (depth == 0) ){ <span class="comment">//161 -&gt; 60 2-qubit gate calls</span></div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;                    qSim.applyGateCCX( ctrlIndices.back(), *(auxIndices.begin() + ctrlIndices.size() - 3), qTarget);</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;                    <span class="keywordflow">for</span> (std::size_t i = ctrlIndices.size()-2; i &gt;= 2; i--){</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                        qSim.applyGateCCX( *(ctrlIndices.begin()+i), *(auxIndices.begin() + (i-2)), *(auxIndices.begin() + (i-1)));</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                    }</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                    qSim.applyGateCCX( *(ctrlIndices.begin()), *(ctrlIndices.begin()+1), *(auxIndices.begin()) );</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                    </div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;                    <span class="keywordflow">for</span> (std::size_t i = 2; i &lt;= ctrlIndices.size()-2; i++){</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;                        qSim.applyGateCCX( *(ctrlIndices.begin()+i), *(auxIndices.begin()+(i-2)), *(auxIndices.begin()+(i-1)));</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;                    }</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;                    qSim.applyGateCCX( ctrlIndices.back(), *(auxIndices.begin() + ctrlIndices.size() - 3), qTarget);</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;                    <span class="keywordflow">for</span> (std::size_t i = ctrlIndices.size()-2; i &gt;= 2; i--){</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;                        qSim.applyGateCCX( *(ctrlIndices.begin()+i), *(auxIndices.begin() + (i-2)), *(auxIndices.begin() + (i-1)));</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;                    }</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;                    qSim.applyGateCCX( *(ctrlIndices.begin()), *(ctrlIndices.begin()+1), *(auxIndices.begin()) );</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;                    <span class="keywordflow">for</span> (std::size_t i = 2; i &lt;= ctrlIndices.size()-2; i++){</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                        qSim.applyGateCCX( *(ctrlIndices.begin()+i), *(auxIndices.begin()+(i-2)), *(auxIndices.begin()+(i-1)));</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;                    }</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;                }</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span>(cOps == 3){ <span class="comment">//Optimisation for replacing 17 with 13 2-qubit gate calls</span></div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;                    <span class="comment">//Apply the 13 2-qubit gate calls</span></div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;                    qSim.applyGateCU( <a class="code" href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">gate_cache</a>.gateCacheMap[gateLabel][local_depth+1].first, ctrlIndices[0], qTarget, gateLabel );</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;                    qSim.applyGateCX( ctrlIndices[0], ctrlIndices[1]);</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;                    qSim.applyGateCU( <a class="code" href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">gate_cache</a>.gateCacheMap[gateLabel][local_depth+1].second, ctrlIndices[1], qTarget, gateLabel );</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;                    qSim.applyGateCX( ctrlIndices[0], ctrlIndices[1]);</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;                    qSim.applyGateCU( <a class="code" href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">gate_cache</a>.gateCacheMap[gateLabel][local_depth+1].first, ctrlIndices[1], qTarget, gateLabel );</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;                    qSim.applyGateCX( ctrlIndices[1], ctrlIndices[2]);</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;                    qSim.applyGateCU( <a class="code" href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">gate_cache</a>.gateCacheMap[gateLabel][local_depth+1].second, ctrlIndices[2], qTarget, gateLabel );</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;                    qSim.applyGateCX( ctrlIndices[0], ctrlIndices[2]);</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;                    qSim.applyGateCU( <a class="code" href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">gate_cache</a>.gateCacheMap[gateLabel][local_depth+1].first, ctrlIndices[2], qTarget, gateLabel );</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;                    qSim.applyGateCX( ctrlIndices[1], ctrlIndices[2]);</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;                    qSim.applyGateCU( <a class="code" href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">gate_cache</a>.gateCacheMap[gateLabel][local_depth+1].second, ctrlIndices[2], qTarget, gateLabel );</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                    qSim.applyGateCX( ctrlIndices[0], ctrlIndices[2]);</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;                    qSim.applyGateCU( <a class="code" href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">gate_cache</a>.gateCacheMap[gateLabel][local_depth+1].first, ctrlIndices[2], qTarget, gateLabel );</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;                }</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cOps &gt;= 2 &amp;&amp; cOps !=3){</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                    std::vector&lt;std::size_t&gt; subCtrlIndices(ctrlIndices.begin(), ctrlIndices.end()-1);</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                    qSim.applyGateCU( <a class="code" href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">gate_cache</a>.gateCacheMap[gateLabel][local_depth].first, ctrlIndices.back(), qTarget, gateLabel );</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                    <a class="code" href="a00787.html#af455a12f17698722468f2bcd4b30a03f">applyNQubitControl</a>(qSim, subCtrlIndices, auxIndices, ctrlIndices.back(), <span class="stringliteral">&quot;X&quot;</span>, qSim.getGateX(), 0 );</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;                    qSim.applyGateCU( <a class="code" href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">gate_cache</a>.gateCacheMap[gateLabel][local_depth].second, ctrlIndices.back(), qTarget, gateLabel );</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;                    <a class="code" href="a00787.html#af455a12f17698722468f2bcd4b30a03f">applyNQubitControl</a>(qSim, subCtrlIndices, auxIndices, ctrlIndices.back(), <span class="stringliteral">&quot;X&quot;</span>, qSim.getGateX(), 0 );</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;                    <a class="code" href="a00787.html#af455a12f17698722468f2bcd4b30a03f">applyNQubitControl</a>(qSim, subCtrlIndices, auxIndices, qTarget, gateLabel, <a class="code" href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">gate_cache</a>.gateCacheMap[gateLabel][local_depth+1].first, local_depth );</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;                }</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;                <span class="comment">//If the number of control qubits is less than 2, assume we have decomposed sufficiently</span></div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;                <span class="keywordflow">else</span>{</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;                    qSim.applyGateCU(<a class="code" href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">gate_cache</a>.gateCacheMap[gateLabel][depth].first, ctrlIndices[0], qTarget, gateLabel); <span class="comment">//The first decomposed matrix value is used here</span></div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;                }</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;            }</div><div class="ttc" id="a00787_html_ac427299b83ca823451eed3d0ac3d4be9"><div class="ttname"><a href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">QNLP::NCU::gate_cache</a></div><div class="ttdeci">GateCache&lt; SimulatorType &gt; gate_cache</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00051">ncu.hpp:51</a></div></div>
<div class="ttc" id="a00787_html_af455a12f17698722468f2bcd4b30a03f"><div class="ttname"><a href="a00787.html#af455a12f17698722468f2bcd4b30a03f">QNLP::NCU::applyNQubitControl</a></div><div class="ttdeci">void applyNQubitControl(SimulatorType &amp;qSim, const std::vector&lt; std::size_t &gt; ctrlIndices, const std::vector&lt; std::size_t &gt; auxIndices, const unsigned int qTarget, const std::string gateLabel, const Mat2x2Type &amp;U, const std::size_t depth)</div><div class="ttdoc">Decompose n-qubit controlled op into 1 and 2 qubit gates. Control indices can be in any specified loc...</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00136">ncu.hpp:136</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="a00026_source.html#l00051">QNLP::NCU&lt; SimulatorType &gt;::gate_cache</a>.</p>

</div>
</div>
<a id="a18bd36e85b79be7bd482f26cda350d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18bd36e85b79be7bd482f26cda350d85">&#9670;&nbsp;</a></span>clearMaps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SimulatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00787.html">QNLP::NCU</a>&lt; SimulatorType &gt;::clearMaps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the maps of stored sqrt matrices. </p>

<p class="definition">Definition at line <a class="el" href="a00026_source.html#l00121">121</a> of file <a class="el" href="a00026_source.html">ncu.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                            {</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;                <a class="code" href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">gate_cache</a>.clearCache();</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;            }</div><div class="ttc" id="a00787_html_ac427299b83ca823451eed3d0ac3d4be9"><div class="ttname"><a href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">QNLP::NCU::gate_cache</a></div><div class="ttdeci">GateCache&lt; SimulatorType &gt; gate_cache</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00051">ncu.hpp:51</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="a00026_source.html#l00051">QNLP::NCU&lt; SimulatorType &gt;::gate_cache</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00026_source.html#l00085">QNLP::NCU&lt; SimulatorType &gt;::~NCU()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="a00787_a18bd36e85b79be7bd482f26cda350d85_icgraph.png" border="0" usemap="#a00787_a18bd36e85b79be7bd482f26cda350d85_icgraph" alt=""/></div>
<map name="a00787_a18bd36e85b79be7bd482f26cda350d85_icgraph" id="a00787_a18bd36e85b79be7bd482f26cda350d85_icgraph">
<area shape="rect"  title="Clears the maps of stored sqrt matrices." alt="" coords="192,5,356,32"/>
<area shape="rect"  href="a00787.html#a99b0a71f74e7420c533c5bfa318584c5" title="Destroy the NCU object." alt="" coords="5,5,144,32"/>
</map>
</div>

</div>
</div>
<a id="a02ea045ed7096c4e6c0001db5a3e0cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ea045ed7096c4e6c0001db5a3e0cd5">&#9670;&nbsp;</a></span>find_optimal_params()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SimulatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00791.html">OptParamsCX</a> <a class="el" href="a00787.html">QNLP::NCU</a>&lt; SimulatorType &gt;::find_optimal_params </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_ctrl_lines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of 2-qubit operations an optimised decomposition will make for nCX. Caches intermediate results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_ctrl_lines</td><td><a class="el" href="a00943.html">The</a> number of control lines in the nCX call </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::size_t <a class="el" href="a00943.html">The</a> number of 2-qubit gate calls </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00026_source.html#l00286">286</a> of file <a class="el" href="a00026_source.html">ncu.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;                                                                 {</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;            <span class="comment">//If entry exists, return it</span></div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;            <span class="keyword">auto</span> it = <a class="code" href="a00787.html#a21990a8ce5be79b6311f7a4d59aa3a3a">opt_op_call_params_CX</a>.find(num_ctrl_lines);</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;            <span class="keywordflow">if</span> ( it != <a class="code" href="a00787.html#a21990a8ce5be79b6311f7a4d59aa3a3a">opt_op_call_params_CX</a>.end() ){</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;                std::cout &lt;&lt; <span class="stringliteral">&quot;FOUND OPTIMAL PARAMS SEARCH FOR CTRL=&quot;</span> &lt;&lt; num_ctrl_lines &lt;&lt; <span class="stringliteral">&quot;  M=&quot;</span> &lt;&lt; it-&gt;second.m &lt;&lt; <span class="stringliteral">&quot; L=&quot;</span> &lt;&lt; it-&gt;second.l &lt;&lt; <span class="stringliteral">&quot; OPS=&quot;</span> &lt;&lt; it-&gt;second.num_ops &lt;&lt; std::endl;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;                <span class="keywordflow">return</span> it-&gt;second;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;            }</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;            </div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;            <span class="comment">//Determine number of comparisons to make.</span></div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;            std::size_t num_comp = static_cast&lt;std::size_t&gt;(std::floor((<span class="keywordtype">float</span>)(num_ctrl_lines)/2.0)) +1;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;            OptParamsCX optimal_params;</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;            std::size_t tmp_num_ops;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;            </div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;            <span class="keywordflow">for</span>(std::size_t _m = 2; _m &lt;= num_comp; ++_m){</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                std::size_t _l = (num_ctrl_lines - _m + 1);</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                tmp_num_ops = <a class="code" href="a00787.html#ae14cf264b2e8440bd24c356cdd6cc3dd">get_ops_for_params</a>(_l, _m);</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;                <span class="keywordflow">if</span> (_m == 2){</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;                    optimal_params = OptParamsCX{num_ctrl_lines, _m, _l, tmp_num_ops};</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;                }</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( tmp_num_ops &lt; optimal_params.num_ops){</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                    optimal_params = OptParamsCX{num_ctrl_lines, _m, _l, tmp_num_ops};</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;                }</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                std::cout &lt;&lt; <span class="stringliteral">&quot;OPTIMAL PARAMS SEARCH FOR CTRL=&quot;</span> &lt;&lt; num_ctrl_lines &lt;&lt; <span class="stringliteral">&quot;  M=&quot;</span> &lt;&lt; _m &lt;&lt; <span class="stringliteral">&quot; L=&quot;</span> &lt;&lt; _l &lt;&lt; <span class="stringliteral">&quot; OPS=&quot;</span> &lt;&lt; tmp_num_ops &lt;&lt; std::endl;</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;            }</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;            <a class="code" href="a00787.html#a21990a8ce5be79b6311f7a4d59aa3a3a">opt_op_call_params_CX</a>[num_ctrl_lines] = optimal_params;</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;            <a class="code" href="a00787.html#a9203cd5393e0537cc604a25a59f4c716">op_call_counts_CX</a>[num_ctrl_lines] = optimal_params.num_ops;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;            std::cout &lt;&lt; <span class="stringliteral">&quot;OPTIMAL PARAMS FOR CTRL=&quot;</span> &lt;&lt; num_ctrl_lines &lt;&lt; <span class="stringliteral">&quot;  M=&quot;</span> &lt;&lt; optimal_params.m &lt;&lt; <span class="stringliteral">&quot; L=&quot;</span> &lt;&lt; optimal_params.l &lt;&lt; <span class="stringliteral">&quot; OPS=&quot;</span> &lt;&lt; optimal_params.num_ops &lt;&lt; std::endl;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;            <span class="keywordflow">return</span> optimal_params;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;        }</div><div class="ttc" id="a00787_html_a9203cd5393e0537cc604a25a59f4c716"><div class="ttname"><a href="a00787.html#a9203cd5393e0537cc604a25a59f4c716">QNLP::NCU::op_call_counts_CX</a></div><div class="ttdeci">std::unordered_map&lt; std::size_t, std::size_t &gt; op_call_counts_CX</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00047">ncu.hpp:47</a></div></div>
<div class="ttc" id="a00787_html_a21990a8ce5be79b6311f7a4d59aa3a3a"><div class="ttname"><a href="a00787.html#a21990a8ce5be79b6311f7a4d59aa3a3a">QNLP::NCU::opt_op_call_params_CX</a></div><div class="ttdeci">std::unordered_map&lt; std::size_t, OptParamsCX &gt; opt_op_call_params_CX</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00048">ncu.hpp:48</a></div></div>
<div class="ttc" id="a00787_html_ae14cf264b2e8440bd24c356cdd6cc3dd"><div class="ttname"><a href="a00787.html#ae14cf264b2e8440bd24c356cdd6cc3dd">QNLP::NCU::get_ops_for_params</a></div><div class="ttdeci">std::size_t get_ops_for_params(std::size_t l, std::size_t m)</div><div class="ttdoc">Helper method to get optimised number of 2-gate ops for given decomposition params.</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00275">ncu.hpp:275</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="a00026_source.html#l00275">QNLP::NCU&lt; SimulatorType &gt;::get_ops_for_params()</a>, <a class="el" href="a00026_source.html#l00043">QNLP::NCU&lt; SimulatorType &gt;::OptParamsCX::l</a>, <a class="el" href="a00026_source.html#l00042">QNLP::NCU&lt; SimulatorType &gt;::OptParamsCX::m</a>, <a class="el" href="a00026_source.html#l00044">QNLP::NCU&lt; SimulatorType &gt;::OptParamsCX::num_ops</a>, <a class="el" href="a00026_source.html#l00047">QNLP::NCU&lt; SimulatorType &gt;::op_call_counts_CX</a>, and <a class="el" href="a00026_source.html#l00048">QNLP::NCU&lt; SimulatorType &gt;::opt_op_call_params_CX</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="a00787_a02ea045ed7096c4e6c0001db5a3e0cd5_cgraph.png" border="0" usemap="#a00787_a02ea045ed7096c4e6c0001db5a3e0cd5_cgraph" alt=""/></div>
<map name="a00787_a02ea045ed7096c4e6c0001db5a3e0cd5_cgraph" id="a00787_a02ea045ed7096c4e6c0001db5a3e0cd5_cgraph">
<area shape="rect"  title="Returns the number of 2&#45;qubit operations an optimised decomposition will make for nCX...." alt="" coords="5,5,179,47"/>
<area shape="rect"  href="a00787.html#ae14cf264b2e8440bd24c356cdd6cc3dd" title="Helper method to get optimised number of 2&#45;gate ops for given decomposition params." alt="" coords="227,5,376,47"/>
<area shape="rect"  href="a00787.html#a2f8a86e0603ce137658f27a2f9b30b72" title="Returns the number of 2&#45;qubit operations a non optimised decomposition will make. Cache intermediate ..." alt="" coords="424,13,601,39"/>
</map>
</div>

</div>
</div>
<a id="a2f8a86e0603ce137658f27a2f9b30b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8a86e0603ce137658f27a2f9b30b72">&#9670;&nbsp;</a></span>get_op_calls()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SimulatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00787.html">QNLP::NCU</a>&lt; SimulatorType &gt;::get_op_calls </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_ctrl_lines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of 2-qubit operations a non optimised decomposition will make. Cache intermediate results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_ctrl_lines</td><td><a class="el" href="a00943.html">The</a> number of control lines in the <a class="el" href="a00787.html" title="Class definition for applying n-qubit controlled unitary operations.">NCU</a> call </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::size_t <a class="el" href="a00943.html">The</a> number of 2-qubit gate calls </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00026_source.html#l00247">247</a> of file <a class="el" href="a00026_source.html">ncu.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;                                                        {</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;            std::size_t num_ops = 0;</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;            <span class="keyword">auto</span> it = <a class="code" href="a00787.html#a9203cd5393e0537cc604a25a59f4c716">op_call_counts_CX</a>.find(num_ctrl_lines);</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;            <span class="keywordflow">if</span> ( it != <a class="code" href="a00787.html#a9203cd5393e0537cc604a25a59f4c716">op_call_counts_CX</a>.end() ){</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;                std::cout &lt;&lt; <span class="stringliteral">&quot;get_op_calls CTRL=&quot;</span> &lt;&lt; num_ctrl_lines &lt;&lt; <span class="stringliteral">&quot;  OPS=&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;                <span class="keywordflow">return</span> it-&gt;second;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;            }</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (num_ctrl_lines &gt;= 2){</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;                num_ops += (2 + 3*<a class="code" href="a00787.html#a2f8a86e0603ce137658f27a2f9b30b72">get_op_calls</a>(num_ctrl_lines-1));</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;            }</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;            <span class="keywordflow">else</span>{</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;                num_ops += 1;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;            }</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;            <a class="code" href="a00787.html#a9203cd5393e0537cc604a25a59f4c716">op_call_counts_CX</a>[num_ctrl_lines] = num_ops;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;            std::cout &lt;&lt; <span class="stringliteral">&quot;get_op_calls CTRL=&quot;</span> &lt;&lt; num_ctrl_lines &lt;&lt; <span class="stringliteral">&quot;  OPS=&quot;</span> &lt;&lt; num_ops &lt;&lt; std::endl;</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;            <span class="keywordflow">return</span> num_ops;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;        }</div><div class="ttc" id="a00787_html_a9203cd5393e0537cc604a25a59f4c716"><div class="ttname"><a href="a00787.html#a9203cd5393e0537cc604a25a59f4c716">QNLP::NCU::op_call_counts_CX</a></div><div class="ttdeci">std::unordered_map&lt; std::size_t, std::size_t &gt; op_call_counts_CX</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00047">ncu.hpp:47</a></div></div>
<div class="ttc" id="a00787_html_a2f8a86e0603ce137658f27a2f9b30b72"><div class="ttname"><a href="a00787.html#a2f8a86e0603ce137658f27a2f9b30b72">QNLP::NCU::get_op_calls</a></div><div class="ttdeci">std::size_t get_op_calls(std::size_t num_ctrl_lines)</div><div class="ttdoc">Returns the number of 2-qubit operations a non optimised decomposition will make. Cache intermediate ...</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00247">ncu.hpp:247</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="a00026_source.html#l00047">QNLP::NCU&lt; SimulatorType &gt;::op_call_counts_CX</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00026_source.html#l00275">QNLP::NCU&lt; SimulatorType &gt;::get_ops_for_params()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="a00787_a2f8a86e0603ce137658f27a2f9b30b72_icgraph.png" border="0" usemap="#a00787_a2f8a86e0603ce137658f27a2f9b30b72_icgraph" alt=""/></div>
<map name="a00787_a2f8a86e0603ce137658f27a2f9b30b72_icgraph" id="a00787_a2f8a86e0603ce137658f27a2f9b30b72_icgraph">
<area shape="rect"  title="Returns the number of 2&#45;qubit operations a non optimised decomposition will make. Cache intermediate ..." alt="" coords="424,13,601,39"/>
<area shape="rect"  href="a00787.html#ae14cf264b2e8440bd24c356cdd6cc3dd" title="Helper method to get optimised number of 2&#45;gate ops for given decomposition params." alt="" coords="227,5,376,47"/>
<area shape="rect"  href="a00787.html#a02ea045ed7096c4e6c0001db5a3e0cd5" title="Returns the number of 2&#45;qubit operations an optimised decomposition will make for nCX...." alt="" coords="5,5,179,47"/>
</map>
</div>

</div>
</div>
<a id="ae14cf264b2e8440bd24c356cdd6cc3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14cf264b2e8440bd24c356cdd6cc3dd">&#9670;&nbsp;</a></span>get_ops_for_params()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SimulatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00787.html">QNLP::NCU</a>&lt; SimulatorType &gt;::get_ops_for_params </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper method to get optimised number of 2-gate ops for given decomposition params. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>multi-control gate partition 2, l = n-m-1 </td></tr>
    <tr><td class="paramname">m</td><td>multi-control gate partition 1, m \in {2,...,n-3} </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const std::size_t </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00026_source.html#l00275">275</a> of file <a class="el" href="a00026_source.html">ncu.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                                                                     {</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;            <span class="keywordflow">return</span> 2*(<a class="code" href="a00787.html#a2f8a86e0603ce137658f27a2f9b30b72">get_op_calls</a>(m) + <a class="code" href="a00787.html#a2f8a86e0603ce137658f27a2f9b30b72">get_op_calls</a>(l));</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;        }</div><div class="ttc" id="a00787_html_a2f8a86e0603ce137658f27a2f9b30b72"><div class="ttname"><a href="a00787.html#a2f8a86e0603ce137658f27a2f9b30b72">QNLP::NCU::get_op_calls</a></div><div class="ttdeci">std::size_t get_op_calls(std::size_t num_ctrl_lines)</div><div class="ttdoc">Returns the number of 2-qubit operations a non optimised decomposition will make. Cache intermediate ...</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00247">ncu.hpp:247</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="a00026_source.html#l00247">QNLP::NCU&lt; SimulatorType &gt;::get_op_calls()</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00026_source.html#l00286">QNLP::NCU&lt; SimulatorType &gt;::find_optimal_params()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="a00787_ae14cf264b2e8440bd24c356cdd6cc3dd_cgraph.png" border="0" usemap="#a00787_ae14cf264b2e8440bd24c356cdd6cc3dd_cgraph" alt=""/></div>
<map name="a00787_ae14cf264b2e8440bd24c356cdd6cc3dd_cgraph" id="a00787_ae14cf264b2e8440bd24c356cdd6cc3dd_cgraph">
<area shape="rect"  title="Helper method to get optimised number of 2&#45;gate ops for given decomposition params." alt="" coords="5,5,155,47"/>
<area shape="rect"  href="a00787.html#a2f8a86e0603ce137658f27a2f9b30b72" title="Returns the number of 2&#45;qubit operations a non optimised decomposition will make. Cache intermediate ..." alt="" coords="203,13,380,39"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="a00787_ae14cf264b2e8440bd24c356cdd6cc3dd_icgraph.png" border="0" usemap="#a00787_ae14cf264b2e8440bd24c356cdd6cc3dd_icgraph" alt=""/></div>
<map name="a00787_ae14cf264b2e8440bd24c356cdd6cc3dd_icgraph" id="a00787_ae14cf264b2e8440bd24c356cdd6cc3dd_icgraph">
<area shape="rect"  title="Helper method to get optimised number of 2&#45;gate ops for given decomposition params." alt="" coords="227,5,376,47"/>
<area shape="rect"  href="a00787.html#a02ea045ed7096c4e6c0001db5a3e0cd5" title="Returns the number of 2&#45;qubit operations an optimised decomposition will make for nCX...." alt="" coords="5,5,179,47"/>
</map>
</div>

</div>
</div>
<a id="ac3ac9e40555c41856235dbd8e3be0d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ac9e40555c41856235dbd8e3be0d46">&#9670;&nbsp;</a></span>getGateCache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SimulatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00935.html">GateCache</a>&lt;SimulatorType&gt;&amp; <a class="el" href="a00787.html">QNLP::NCU</a>&lt; SimulatorType &gt;::getGateCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Map of cached gates. Keys are strings, and values are vectors of paired (gate, gate adjoint) types where the index give the value of (gate)^(1/2^i) </p>
<dl class="section return"><dt>Returns</dt><dd>GateCache&lt;SimulatorType&gt; type </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00026_source.html#l00113">113</a> of file <a class="el" href="a00026_source.html">ncu.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                                                    {</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">gate_cache</a>;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;            }</div><div class="ttc" id="a00787_html_ac427299b83ca823451eed3d0ac3d4be9"><div class="ttname"><a href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">QNLP::NCU::gate_cache</a></div><div class="ttdeci">GateCache&lt; SimulatorType &gt; gate_cache</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00051">ncu.hpp:51</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="a00026_source.html#l00051">QNLP::NCU&lt; SimulatorType &gt;::gate_cache</a>.</p>

</div>
</div>
<a id="ac911ebbd5c14ebe7ae37737b8c2b6182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac911ebbd5c14ebe7ae37737b8c2b6182">&#9670;&nbsp;</a></span>initialiseMaps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SimulatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00787.html">QNLP::NCU</a>&lt; SimulatorType &gt;::initialiseMaps </td>
          <td>(</td>
          <td class="paramtype">SimulatorType &amp;&#160;</td>
          <td class="paramname"><em>qSim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_ctrl_lines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the PauliX and the given unitary U to the maps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00026_source.html#l00095">95</a> of file <a class="el" href="a00026_source.html">ncu.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;                                                                                {</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;                <a class="code" href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">gate_cache</a>.initCache(qSim, num_ctrl_lines);</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;            }</div><div class="ttc" id="a00787_html_ac427299b83ca823451eed3d0ac3d4be9"><div class="ttname"><a href="a00787.html#ac427299b83ca823451eed3d0ac3d4be9">QNLP::NCU::gate_cache</a></div><div class="ttdeci">GateCache&lt; SimulatorType &gt; gate_cache</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00051">ncu.hpp:51</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="a00026_source.html#l00051">QNLP::NCU&lt; SimulatorType &gt;::gate_cache</a>.</p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a00ae431de3e099653ea403b04879111e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ae431de3e099653ea403b04879111e">&#9670;&nbsp;</a></span>default_gates</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SimulatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt;std::string&gt; <a class="el" href="a00787.html">QNLP::NCU</a>&lt; SimulatorType &gt;::default_gates</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00026_source.html#l00031">31</a> of file <a class="el" href="a00026_source.html">ncu.hpp</a>.</p>

</div>
</div>
<a id="ac427299b83ca823451eed3d0ac3d4be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac427299b83ca823451eed3d0ac3d4be9">&#9670;&nbsp;</a></span>gate_cache</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SimulatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00935.html">GateCache</a>&lt;SimulatorType&gt; <a class="el" href="a00787.html">QNLP::NCU</a>&lt; SimulatorType &gt;::gate_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00026_source.html#l00051">51</a> of file <a class="el" href="a00026_source.html">ncu.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00026_source.html#l00104">QNLP::NCU&lt; SimulatorType &gt;::addToMaps()</a>, <a class="el" href="a00026_source.html#l00136">QNLP::NCU&lt; SimulatorType &gt;::applyNQubitControl()</a>, <a class="el" href="a00026_source.html#l00121">QNLP::NCU&lt; SimulatorType &gt;::clearMaps()</a>, <a class="el" href="a00026_source.html#l00113">QNLP::NCU&lt; SimulatorType &gt;::getGateCache()</a>, <a class="el" href="a00026_source.html#l00095">QNLP::NCU&lt; SimulatorType &gt;::initialiseMaps()</a>, <a class="el" href="a00026_source.html#l00077">QNLP::NCU&lt; SimulatorType &gt;::NCU()</a>, and <a class="el" href="a00026_source.html#l00085">QNLP::NCU&lt; SimulatorType &gt;::~NCU()</a>.</p>

</div>
</div>
<a id="a1f01335e87242dd9064ae46ea71eb003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f01335e87242dd9064ae46ea71eb003">&#9670;&nbsp;</a></span>num_gate_ops</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SimulatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00787.html">QNLP::NCU</a>&lt; SimulatorType &gt;::num_gate_ops</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00026_source.html#l00057">57</a> of file <a class="el" href="a00026_source.html">ncu.hpp</a>.</p>

</div>
</div>
<a id="a9203cd5393e0537cc604a25a59f4c716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9203cd5393e0537cc604a25a59f4c716">&#9670;&nbsp;</a></span>op_call_counts_CX</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SimulatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::size_t, std::size_t&gt; <a class="el" href="a00787.html">QNLP::NCU</a>&lt; SimulatorType &gt;::op_call_counts_CX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00026_source.html#l00047">47</a> of file <a class="el" href="a00026_source.html">ncu.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00026_source.html#l00286">QNLP::NCU&lt; SimulatorType &gt;::find_optimal_params()</a>, <a class="el" href="a00026_source.html#l00247">QNLP::NCU&lt; SimulatorType &gt;::get_op_calls()</a>, and <a class="el" href="a00026_source.html#l00064">QNLP::NCU&lt; SimulatorType &gt;::NCU()</a>.</p>

</div>
</div>
<a id="a21990a8ce5be79b6311f7a4d59aa3a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21990a8ce5be79b6311f7a4d59aa3a3a">&#9670;&nbsp;</a></span>opt_op_call_params_CX</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SimulatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::size_t, <a class="el" href="a00791.html">OptParamsCX</a>&gt; <a class="el" href="a00787.html">QNLP::NCU</a>&lt; SimulatorType &gt;::opt_op_call_params_CX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00026_source.html#l00048">48</a> of file <a class="el" href="a00026_source.html">ncu.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00026_source.html#l00286">QNLP::NCU&lt; SimulatorType &gt;::find_optimal_params()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/mlxd/Desktop/intel-qnlp-rc2/modules/gate_ops/ncu/<a class="el" href="a00026_source.html">ncu.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00186.html">QNLP</a></li><li class="navelem"><a class="el" href="a00787.html">NCU</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
